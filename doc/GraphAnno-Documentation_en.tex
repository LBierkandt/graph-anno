\documentclass[12pt]{scrartcl}
\usepackage{fontspec}
\usepackage{linguex}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{framed}
\usepackage{url}
\usepackage{xcolor}
\definecolor{darkblue}{rgb}{0,0,.5}
\usepackage[pdfpagemode=UseNone, colorlinks=true, allcolors=darkblue]{hyperref}

%\KOMAoptions{BCOR=16mm}
\KOMAoptions{DIV=10}


\setmainfont[WordSpace={1,1.15,1},Numbers=Proportional]{Linux Libertine O}
\setsansfont[Scale=MatchLowercase]{Linux Biolinum O}
\setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}

\textheight22.4cm % 42 Zeilen {\baselinestretch}{1.05}
% \voffset-4mm
% %\headsep4mm


%\parindent0pt
%\parsep0ex
\setkomafont{sectioning}{\rmfamily}%\bfseries}
%\setcounter{secnumdepth}{1}
%\setcounter{tocdepth}{2}
%\qtreecenterfalse
\frenchspacing

\let\origitemize\itemize
\def\itemize{\origitemize\itemsep-0.5ex}
\let\origenumerate\enumerate
\def\enumerate{\origenumerate\itemsep-0.5ex}
%\let\origdescr\description
%\def\description{\origdescr\itemsep-0.5ex}
\renewcommand{\labelitemi}{–}
\renewcommand{\labelitemii}{-}
\newcommand{\anf}[1]{‚#1‘}
\newcommand{\ti}{\char"223C}
\newcommand{\quo}{\char"0022}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
%\renewcommand{\bottomfraction}{1}

\lstset{basicstyle=\renewcommand{\baselinestretch}{1}\tt, aboveskip=0em, belowskip=0em, tabsize=4, xleftmargin=.5em}


\title{\LARGE GraphAnno\\ \large An annotation and query tool\\for graph-based linguistic annotations}
\author{Lennart Bierkandt\\\large Friedrich-Schiller-Universität Jena\\[-.2em]\large post@lennartbierkandt.de}
\date{Version of \today}


\renewcommand{\glt}{\vspace{-\Extopsep}}
\renewcommand{\firstrefdash}{}
\newcommand{\re}{\vspace{-.33\Extopsep}} %{-1.33\Extopsep} für normalen Zeilenabstand bei \ex. mit \gll, 0.66 ohne \gll
\newcommand{\regll}{\vspace{-\Extopsep}\gll}
\let\eachwordtwo=\glosse
\glossglue = 5pt plus 2pt minus 2pt


\newenvironment{figurel}{\begin{figure}[htb]\vskip 2ex}{\end{figure}}
\newenvironment{tablel}{\begin{table}[htb]\vskip 2ex}{\end{table}}

\newenvironment{anmerkung}{\par{\ }\par\sf\color{black!60}\noindent\textbf{Remark:}\par}{\newline\par}

\newcommand{\kommentar}[1]{}

\setlength{\abovecaptionskip}{0ex}








\begin{document}

\maketitle

\renewcommand{\baselinestretch}{1.05}\normalsize

\tableofcontents


\section{The annotation graph}

\subsection{Graph format}

A graph in GraphAnno consists of a set of nodes and directed edges.
Nodes and edges bear attributes in the form of key-value pairs, that are used for the linguistic annotation as well as the structuring and visualization of the graph.
There are some attributes – like the attribute \texttt{type}, that differentiates the types of nodes and edges (annotation nodes, tokens, sentence nodes; annotation edges, ordering edges, section edges) – that serve the internal representation of the graph and are not edited directly.
Under the key \texttt{attr}, however, there is a group of key-value pairs which serve the linguistic annotations and the representation of layers and which are edited by the user directly.
They will be called \textit{annotation attributes} in the following.

The graph in GraphAnno is segmented in sentences – units that that are used for structuring and displaying the corpus, but that do not necessarily correspond to real sentences (how ever these may be defined).
There is a sentence node (bearing the attribute \texttt{type:s}) for every sentence, that bears information concerning the whole sentence.
This includes, e.g., source, medium, speaker or the like.
The annotations of this node is displayed in the light grey area below the sentence graph and under the text of the sentence (blue font) in black font.
The information to which sentence a node of the graph belongs is represented by an (invisible) edge with \texttt{type:s} that links the node in question to the sentence node.
Edges are not linked to a sentence node; their affiliation follows from the affiliation of their start and end nodes.

Token nodes are characterized by the attribute \texttt{type:t} and they carry the annotation attribute \texttt{token} with the token text as value.
The order of the tokens of a sentence (as well as the sentence nodes themselves) is defined by ordering edges (with \texttt{type:o}) that link each node to its successor.
These edges are needed for the correct visualization and for traversal; the are, however, not displayed and cannot be manipulated directly.

Among the annotation attributes, nodes and edges may bear the \texttt{cat} attribute, that has no special meaning for the graph, but which is desplayed prominently on top of the other annotations and without the key.
Nodes and edges show numbers like \texttt{t23} for tokens, \texttt{n23} for other nodes and \texttt{e23} for edges, that are used for referencing the elements in annotation commands.
These numbers are not stored in the graph model but generated dynamically each time the displayed graph is rendered.

GraphAnno also provides the possibility to assign nodes and edges to different layers.
The fact that a node or edge is affiliated to a certain layer is represented by that element bearing an annotation (among the annotation attributes) with the key corresponding to the layer and the value \texttt{t} (for \textit{true}).
This representation allows for elements to belong to more than one layer, with the consequence that layers my overlap in an arbitrary manner.
Nodes and edges of different layers may be displayed in different colors and aligned in different ways (hierachically or horizontally).
Tokens do not belong to any layer; they are displayed in black by default.



\subsection{Configuration}\label{konfiguration}

\subsubsection{Layers and visualization}\label{ebenenkonfiguration}

The window for configuration of the layers of the currently loaded graph and its visualization is opened with the commmand line command \texttt{config}.

In the section \textit{general settings}, you can configure the settings for nodes and edges that do not belong to any layer.\footnote{Depending on the browser you use, the color fields are displayed as color picker or as simple text field. In the latter case, you have to provide the color as hexadecimal RGB value: A hash (\texttt{\#}) followed by three two-digit hexadecimal numbers for red, green and blue, respectively. \texttt{\#000000}, e.g., stands for black, \texttt{\#ffffff} for white, \texttt{\#ff0000} for light red etc.}
\textit{Default color} applies to all nodes and edges that are not tokens and that do not belong to any layer, \textit{token color} applies to tokens, \textit{found color} is used for the highlighting of nodes and edges found in a search, and \textit{filtered color} for elements that are filtered out by the filter function.
The setting for \textit{edge weight} affects the layout of the displayed graph and shows its effect only when edges with different weight are present (details will follow in the next paragraph).

In the section \textit{layers}, you can configure the layers of the graph.
The \textit{name} is an arbitrary label for the layer, that will be shown in the dropdown field for the layer selection.
\textit{Attribute} is the attribute that will be set to \texttt{t} for elements that belong to the layer in question.
The \textit{shortcut} is an identifier that can be used for the annotation of elements (cf. \ref{befehl-n}); this shortcut may only consist of alphanumeric characters and must not have the same structure as element references (i.e., \texttt{t}, \texttt{n} or \texttt{e} followed by a number, or  \texttt{m}; cf. \ref{befehl-a}).
\textit{Color} means the color that is used for displaying the elements of the layer; \textit{edge weight} is the weight of the layer’s edges.
The heigher this value (integer values), the shorter the rendering algorithm will try to make the edges.
When you create two layers, one with a high edge weight and one with a low edge weight, the graph will be rendered such that the graph of the first layer is as compact as possible; the elements of the second layer will be placed in a way that they distort the first layer only to a low degree.
If you enter \texttt{0} as edge weight, the edges will not enforce a hierachy between the nodes of that layer (otherwise, the start node of an edge is always placed higher than the end node).
If a negative value is entered, all nodes of that layer are displayed horizontally on one tier.

The section \textit{layer combinations} contains the settings for elements that belong to multiple layers.
Via the checkboxes under \textit{attributes} you determine, to which layers an element has to belong in order to be subject to the definition of the combination in question.
The other settings work like those described for the \textit{layers}, and for those elements that belong to the layer combination, they override the values given for the single layers.

Under \textit{search makros} you can enter predefined graph-specific search makros as described in Section \ref{def}.
These makros are then available for search queries in the graph.
In the search makros text area, the definitions (\texttt{def ...}) have to be enterd each on its own line.

\subsubsection{Permitted annotations / tagset}\label{erlaubteannotationen}

In the window open by the command \texttt{tagste}, you can specify which annotation are permitted for the nodes and edges of the graph, i.e., you can define the graph-specific tagset.
Only the keys and values defined here are permitted for the annotation of elements, illicit input is answered with an error message.
Already existing annotations are not affected by changes of the permitted keys and values.

If you do not specify any keys and values, all annotations are permitted.
If you specify keys, only these keys are allowed for annotations.
If you leave the value field for a key empty, then all values are permitted for this key.
If you want to restrict the possible values for a key, you may enter these into the value field of the key in question, separated by spaces.

The notation of the values is subject to the same rules as in the query language (cf. Section \ref{node}, p.\,\pageref{zeichenketten}):
Simple values are entered without further markup; if a value contains special characters (siehe p.\,\pageref{zeichenketten}) it has to be enclosed in double quotes (\texttt{\quo...\quo}).
Additionally – just like in the query language (p.\,\pageref{zeichenketten}) – you may use regular expressions, which are enclosed in slashes (\texttt{/.../}).
In this case the regular expressions are anchored, i.e. an annotation value has to match the whole regular expression in order to be permitted.

\subsubsection{Metadata}

Additionally to the configuration of layers, visualization, search makros and permitted annotations, you may save metadata for a graph as key-value pairs.
The command \texttt{metadata} opens the window, where you can enter an arbitrary number of keys with a text as corresponding value.


\section{Keyboard shortcuts}

In GraphAnno most of the functions related to navigation and display are controlled by keybord shortcuts.
The following is a table of the available shortcuts:

\begin{center}
	\begin{tabular*}{\textwidth}{ll}
		\toprule
		Shortcut & Function \\
		\midrule
		Navigation & \\
		\midrule
			Alt + ←/→ & previous/next sentence\\
			Alt + Home/End & first/last sentence \\
		\midrule
		Graph & \\
		\midrule
			Ctrl + Shift + −/+ & scale down/up graph\\
			Ctrl + Shift + 0 & zoom to fit (wrt. height) \\
			Ctrl + Shift + arrows & move graph\\
			Ctrl + Shift + Home/End & go to left/right edge of graph\\
			Ctrl + Shift + Page up/Page down& go to upper/lower edge of graph\\
			F4 & toggle element references\\
		\midrule
		Window & \\
		\midrule
			F1 & show/hide help window \\
			F2 & show/hide text and sentence annotations\\
			F6 & show/hide filter window\\
			F7 & show/hide search window\\
		\bottomrule
	\end{tabular*}
\end{center}




\section{Command line commands}

\subsection{Data and navigation}

\subsubsection{Load file: \texttt{load}}

With the command \texttt{load}, followed by the file name, you load a graph file inte the work space.
Provide the file name without the extension \texttt{.json}; it has to enclosed in double quotes (\texttt{\quo...\quo}) if it contains spaces.
Files are loaded from the \texttt{data} directory located in the GraphAnno main directory.
Before loading, the work space is cleared from all data.
So, changes that were not saved explicitly (using the command \texttt{save}) are lost.
The name of the loaded file is shown next to the input line on the bottom of the user interface.


\subsubsection{Load file: \texttt{add}}

Just like the command \texttt{load}, the command \texttt{add} loads a file into the work space.
The difference is, that the work space is not cleared – the new file is added and the new sentences are appended to the existing ones.
After adding the file no file is shown as loaded next to the input line and the files cannot be saved separately anymore.


\subsubsection{Save file: \texttt{save}}

The command \texttt{save} saves the work space to a GraphAnno file in the \texttt{data} directory. The file name has to be entered in the same way as with the command \texttt{load}.
If there is a filename indicated next to the input line, the work space can be saved to this file without specifying the file name.
Attention: no warning is issued when an existing file will be overwritten.


\subsubsection{Clear work space: \texttt{clear}}

The command \texttt{clear} clears the work space from all date.
Changes that were not saved are lost.
Next to the input line no file will be indicated anymore.


\subsubsection{Create new sentence: \texttt{ns}}\label{befehl-ns}

With the command \texttt{ns} – followed by one or more sentence names separated by spaces – you can create a new sentence.
The command creates sentence nodes with the corresponding \texttt{name} attribute; afterwards you are directed to the first newly created sentence.


\subsubsection{Delete sentence: \texttt{del}}

The command \texttt{del} deletes the current sentence including the sentence node.


\subsubsection{Gehe zu: \texttt{s}}

In order to navigate from sentence to sentence, you may use (alternatively to keyboard shortcuts or the dropdown field) the command \texttt{s}, followed by the name of the sentence you want to change to.
You are then directed to the first sentence with the given name.


\subsubsection{Export graphics: \texttt{image}}

With the command \texttt{image}, you can export the graphic that GraphAnno is displaying for the current sentence.
The first argument is the desired format.
All formats supported by Graphviz are available, e.g. \texttt{dot}, \texttt{eps}, \texttt{pdf}, \texttt{png} or \texttt{svg}.
See under \url{http://www.graphviz.org/content/output-formats} for the complete list.
The second argument is the name of the new image file (without extension; put the name in double quotes if it contains spaces).
The image will be saved in GraphAnno’s \texttt{images} directory.


\subsubsection{Export corpus: \texttt{export}}\label{befehl-export}

Using the command \texttt{export}, you can export the contents of the work space as a corpus in another format.
The first argument is the format (at present the only fully functional format is \texttt{sql} for the import in GraphInspect; the format \texttt{paula} is theoretically available, but it is heavily restricted with respect to layers), the second argument is the name of the corpus to be saved.
For \texttt{paula} you can optionally specify the name of the corpus document to be created as third argument.
The exported corpus will be saved in GraphAnno’s \texttt{exports} directory.


\subsubsection{Import text: \texttt{import text}}

You can import texts with the command \texttt{import text}. After issuing the command, a window opens where you can enter the text and set the preferences for its processing.
The work space will be cleared before the text is imported (but not as soon as the window opens).
Changes that hadn’t been saved are lost and no file is indicated next to the input line anymore.

In the import window you can choose between two methods of entering your text:
You can upload a text file or you can paste it in the text area.
For the processing of the text there are two methods available, too.
For unedited text you may use the method “punkt segmenter”.
This method uses an automatic segmenter to split the text into sentences and tokens.
In order to process abbreviation etc. correctly, you need to specify the language of the text.

The second processing method is “regular expressions”; this method is made for preformatted texts.
First, you have to enter a string that will be used for segmenting the sentences.
The preset is \texttt{{\textbackslash}n} \footnote{\texttt{{\textbackslash}n} stands for a line break, \texttt{{\textbackslash}t} for a tab.} for a file in which every sentence starts on a new line.
The second string you have to enter a a regular expression that matches the tokens.
The preset here is \texttt{({\textbackslash}S+)}.
This stands for a sequence of non-spaces, so all words that are separated by spaces are matched as tokens.
The purpose of the parentheses is to save the matched string in the variable \texttt{\$1}, so it can be used in the next field.
The next field is for an annotation command (see \ref{befehl-a}) for the tokens, that uses the string matched by the regular expression in the preceding field.
The preset here is \texttt{token:\$1}.
That means that the string matched as token is used for the annotation of the token text.
Another example would be a text tagged for parts of speech, where the part of speech is appended to every word with an underscore.
In this case you would enter the regular expression \texttt{({\textbackslash}S+)\_({\textbackslash}S+)} and the annotation command \texttt{token:\$1 pos:\$2}.
The regular expression in this case finds two strings of non-spaces that are joined by an underscore; the strings are saved to the variables \texttt{\$1} (the word) and \texttt{\$2} (the POS tag).
In the annotation command these variables are used to annotate the token text and the \texttt{pos} attribute.


\vskip4em
\center{\Large tbc.}
\kommentar{

\subsubsection{Toolboxdaten importieren: \texttt{import toolbox}}

Toolboxdateien können mit dem Befehl \texttt{import toolbox} importiert werden. Es öffnet sich ein Fenster, in dem die einzulesende Datei ausgewählt und die Formatbeschreibung eingegeben werden kann. Die Formatbeschreibung wird im JSON-Format angegeben und besteht aus einer Liste von Listen von Markern. Die Listen sind nach Ebenen sortiert – die höchste (\textit{record}) zuerst – und enthalten die der entsprechenden Ebene zugehörigen Marker (ohne Schrägstich). Als Record-ID wird der erste Marker der ersten Ebene (im Bsp. unten \texttt{ref}) verwendet. Dem Marker, auf dessen Grundlage die Token erstellt werden sollen, wird ein Stern vorangestellt. Elemente, die unter der Tokenebene liegen, werden zusammengefügt und in die jeweiligen Token integriert.

Eine Formatbeschreibung für eine Toolboxdatei mit drei Ebenen (Record, Wort, Morphem) könnte z.B. folgendermaßen aussehen:
\begin{verbatim}
  [["ref", "eng"], ["*gw"], ["mph", "ge", "ps"]]
\end{verbatim}

Wie beim Befehl \texttt{load} wird der Arbeitsbereich von GraphAnno vor dem Import geleert. Nicht gespeicherte Änderungen gehen verloren und neben der Eingabeleiste wird keine Datei mehr als geladen angezeigt.


\subsubsection{Konfigurationen ex- und importieren: \texttt{export} und \texttt{import}}

Mit dem Befehl \texttt{export} ist es auch möglich, Graphkonfigurationen zu exportieren, die später mit \texttt{import} in andere Graphen importiert werden können. Dafür wird als erstes Argument der Typ der zu ex- oder importierenden Konfiguration angegeben: \texttt{config} für Darstellungs- und Ebenenkonfiguration (s. \ref{ebenenkonfiguration}), \texttt{tagset} für erlaubte Annotationen (s. \ref{erlaubteannotationen}). Als zweites wird der Name der Datei angegeben, unter dem die Daten gespeichert werden sollen, bzw. die importiert werden soll (ohne Endung). Die exportierte Datei wird im dem Typ entsprechenden Unterordner des \texttt{exports}-Ordners gespeichert. Achtung: beim Import werden bestehende Konfigurationen von den importierten komplett überschrieben.


\subsubsection{Konfigurationen bearbeiten: \texttt{config}, \texttt{tagset} und \texttt{metadata}}

Mit diesen Befehlen öffnet man die Fenster für die in Abschnitt \ref{konfiguration} beschriebenen Einstellungen. \texttt{config} für Darstellung und Ebenen, \texttt{tagset} für erlaubte Annotationen und \texttt{metadata} für Metadaten.


\subsection{Annotationsbefehle}

Die Annotationsbefehle von GraphAnno sind darauf ausgerichtet, daß sie möglichst schnell einzugeben sind. Daher ist ihre Syntax entsprechend reduziert: Sie bestehen aus einem kurzen Befehl (oft nur ein Buchstabe) gefolgt von Parametern, die durch Leerzeichen getrennt sind.

Die Befehle setzen voraus, daß man sich ein einem Satz befindet. D.h., wenn der Arbeitsbereich leer ist (und kein Satz im Satzausfahlfeld angezeigt wird), muß also zunächst mit dem Befehl \texttt{ns} (siehe \ref{befehl-ns}) ein Satz angelegt werden.


\subsubsection{Neuer Knoten: \texttt{n}}\label{befehl-n}

Der Befehl zum Erstellen eines neuen Knotens lautet \texttt{n}, gefolgt von den Attributen, die der neue Knoten haben soll, als Schlüssel-Wert-Paare in der Form \texttt{schlüssel:wert}. Schlüssel und Wert können entweder als einfache Zeichenkette angegeben werden, wenn sie keines der in der GraphAnno-Annotiersprache verwendeten Steuerzeichen (\texttt{␣:\quo})\footnote{Das Zeichen \texttt{␣} steht für das Leerzeichen.} enthalten, oder als Zeichenkette in doppelten Anführungsstrichen (\texttt{\quo...\quo}), die beliebige Zeichen enthalten darf (doppelte Anführungsstriche müssen mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}).
Des weiteren kann die Ebene angegeben werden, der der neue Knoten angehören soll. Dazu dienen die auch für den Befehl \texttt{l} (siehe \ref{l}) geltenden Kürzel, die in der Graphkonfiguration (siehe \ref{konfiguration}) eingestellt werden. Die Angabe der Ebene hat zudem die Wirkung eines Schalters, der wie der Befehl \texttt{l} die Ebene für die folgenden Operationen setzt.

\paragraph*{Befehl \texttt{n} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_n        =   "n " attribute
attribute       =   attribute " " attribute
                    attribut
                    ebenenschalter
attribut        =   schlüssel zeichenkette
schlüssel       =   zeichenkette ":"
zeichenkette    =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """
ebenenschalter  =   <definiert in der Graphkonfiguration>
\end{lstlisting}
\end{framed}


\subsubsection{Neue Kante: \texttt{e}}

Der Befehl zum Anlegen einer neuen Kante lautet \texttt{e}, gefolgt vom Start- und Zielknoten der zu erstellenden  Kante und den Attributen, die sie erhalten soll. Auch die Angabe einer Ebene wie bei \texttt{n} ist möglich.

\paragraph*{Befehl \texttt{e} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_e       =   "e " start_ziel " " start_ziel " " attribute
start_ziel     =   knotenreferenz
                   tokenreferenz
knotenreferenz =   "n" zahl
tokenreferenz  =   "t" zahl
\end{lstlisting}
\end{framed}


\subsubsection{Annotieren: \texttt{a}}\label{befehl-a}

Der Befehl zum Annotieren beliebiger Elemente ist \texttt{a}, gefolgt von den zu annotierenden Elementen und Attributen, mit denen sie annotiert werden sollen (alle angegeben Elemente werden mit allen angegebenen Attributen versehen; auch Ebenekürzel wie bei \texttt{n} können verwendet werden). Die Reihenfolge einzelner Elemente und Attribute ist beliebig. Es können auch Sequenzen von Elementen eines Typs (also \texttt{n}, \texttt{e} oder \texttt{t}) durch Verbinden mit zwei Punkten angegeben werden; beispielsweise werden bei Angabe von \texttt{t3..t7} alle Token von \texttt{t3} bis \texttt{t7} annotiert (die Sequenz kann auch umgekehrt angegeben werden, also \texttt{t7..t3}).

Gleichzeitig können mit dem Befehl \texttt{a} Attribute gelöscht werden. Dazu wird der zu löschende Schlüssel mit Doppelpunkt, aber ohne Wert angegeben.
        %li annotate: <i>a target target ... key:value key:value ...</i>
          %li a r2 n21 t4 abc:def ghi:jkl
          %li a m trans:"Ganz Gallien ist in drei Teile geteilt"

\paragraph*{Befehl \texttt{a} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_a            =   "a " a_parameter
a_parameter         =   a_parameter " " a_parameter
                        elementreferenz
                        attribute
                        schlüssel
elementreferenz     =   knotenreferenz
                        kantenreferenz
                        tokenreferenz
                        metaknotenreferenz
                        elementsequenz
kantenreferenz      =   "e" zahl
metaknotenreferenz  =   "m"
elementsequenz      =   knotensequenz
                        tokensequenz
                        kantensequenz
knotensequenz       =   knotenreferenz ".." knotenreferenz
tokensequenz        =   tokenreferenz ".." tokenreferenz
kantensequenz       =   kantenreferenz ".." kantenreferenz
\end{lstlisting}
\end{framed}




\subsubsection{Elemente löschen: \texttt{d}}

Gelöscht werden Elemente mit dem Befehl \texttt{d}, gefolgt von den zu löschenden Elementen. Werden Knoten gelöscht, werden Ein- und Ausgehende Kanten dieses Knotens ebenfalls gelöscht. Beim Löschen von Tokenknoten aus der Mitte eines Satzes wird die Verbindung zwischen den Token rechts und links des gelöschten Tokens wieder hergestellt.
        %li delete: <i>d target target ...</i>
        %ul
          %li d n21 r12 t7
\paragraph*{Befehl \texttt{d} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_d        =   "d " d_parameter
d_parameter     =   d_parameter " " d_parameter
                    elementreferenz
\end{lstlisting}
\end{framed}


\subsubsection{Knoten unter neuem Mutterknoten gruppieren: \texttt{g} oder \texttt{p}}

Der Gruppierbefehl \texttt{g} oder \texttt{p} erstellt einen neuen Mutterknoten für die angegebenen Knoten. D.h. es wird ein neuer Knoten erstellt und Kanten erzeugt, die diesen mit den zu gruppierenden Knoten verbindet. Die Parameter des Befehls sind die zu gruppierenden Knoten und die Attribute, mit denen der neue Knoten annotiert werden soll. Die Reihenfolge von Knoten und Attributen ist irrelevant. Auch die Angabe einer Ebene wie bei \texttt{n} ist möglich.
        %li group nodes under new mother node: <i>g node node ... key:value key:value ...</i>
        %ul
          %li g t1 t2 n0 typ:S tns:prs
\paragraph*{Befehl \texttt{g} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_g            =   "g " g_parameter
g_parameter         =   g_parameter " " g_parameter
                        knotenreferenz
                        tokenreferenz
                        knotensequenz
                        tokensequenz
                        attribut
                        ebenenschalter
\end{lstlisting}
\end{framed}


\subsubsection{Tochterknoten anhängen: \texttt{h} oder \texttt{c}}

Der Befehl \texttt{h}/\texttt{c} funktioniert wie \texttt{g}/\texttt{p}, mit dem Unterschied, daß anstelle eines Mutterknotens ein neuer gemeinsamer Tochterknoten erstellt wird.
        %li attach new node: <i>h node1 node2 ... key:value key:value ...</i>
        %ul
          %li h n2 n4 typ:R
\paragraph*{Befehl \texttt{h} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_h            =   "h " h_parameter
h_parameter         =   h_parameter " " h_parameter
                        knotenreferenz
                        tokenreferenz
                        knotensequenz
                        tokensequenz
                        attribut
                        ebenenschalter
\end{lstlisting}
\end{framed}


\subsubsection{Neuen Knoten in Kante einfügen: \texttt{ni}}

Mit dem Befehl \texttt{ni} kann man einen Knoten in eine bestehende Kante „einschieben“. Man gibt als Parameter die Attribute für den neuen Knoten und die Kante an. Es wird dann ein neuer Knoten erstellt und die angegebene Kante durch zwei Kanten ersetzt, die alle Annotationen der alten Kante erben und den Startknoten der alten Kante mit dem neuen Knoten sowie den neuen Knoten mit dem Endknoten der alten Kante verbinden.

Gibt man mehrere Kanten an, so wird in jede ein neuer Knoten nach dem eben beschriebenem Verfahren eingeschoben.

\paragraph*{Befehl \texttt{ni} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_ni           =   "ni " ni_parameter
ni_parameter        =   ni_parameter " " ni_parameter
                        kantenreferenz
                        attribut
                        ebenenschalter
\end{lstlisting}
\end{framed}


\subsubsection{Knoten löschen und Mutter-/Tochterknoten verbinden: \texttt{di} und \texttt{do}}

Für den Fall, daß man einen Knoten löschen, aber die Verbindung zwischen Mutter- und Tochterknoten dieses Knotens bestehen lassen möchte, sind die Befehle \texttt{di} bzw. \texttt{do} vorgesehen. Diese Befehle löschen den angegebenen Knoten und verbinden jeden Mutterknoten mit jedem Tochterknoten. \texttt{di} löscht dabei die eingehenden Kanten, \texttt{do} die ausgehenden.

\paragraph*{Befehl \texttt{di}/\texttt{do} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_di_do        =   "di " knotenreferenz+
                        "do " knotenreferenz+
\end{lstlisting}
\end{framed}


\subsubsection{Tokenisieren: \texttt{t} und \texttt{ti}}

Zum Eingeben von Token gibt es die Befehle \texttt{t} und \texttt{ti}. Diese Befehle nehmen eine Folge von durch Leerzeichen getrennten Wörtern als Argument und fügen sie als neue Token in den aktuellen Satz ein. Der Befehl \texttt{t} fügt die neuen Token dabei ans Ende der ggf. schon bestehenden an, \texttt{ti} nimmt als erstes Argument noch eine Tokenreferenz und fügt die neuen Token davor ein.

Die Wörter können als einfache Zeichenkette angeben werden, oder, wenn sie Steuerzeichen (\texttt{␣:\quo}) enthalten, als Zeichenkette in doppelten Anführungsstrichen (\texttt{\quo...\quo}; doppelte Anführungsstriche müssen dann mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}).

\paragraph*{Befehle \texttt{t} und \texttt{ti} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_t        =   "t " wörter
wörter          =   wörter " " wörter
                    wort
wort            =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """

befehl_ti       =   "ti " tokenreferenz " " wörter
\end{lstlisting}
\end{framed}


\subsubsection{Ebenen setzen: \texttt{l}}\label{l}

Mit dem Befehl \texttt{l} wird, alternativ zum Aufklappfeld, die Ebene gesetzt, in der sich die nachfolgend erstellten Elemente befinden sollen. Dafür gelten die in der Graphkonfiguration (siehe \ref{konfiguration}) eingestellten Kürzel.

\paragraph*{Befehl \texttt{l} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_l    =   "l " ebenenschalter
\end{lstlisting}
\end{framed}









\section{Abfragesprache}

\subsection{Suche}

Das Prinzip der Graphsuche von GraphAnno besteht darin, mit einer Menge von Klauseln ein Graphfragment zu beschreiben. Bei der Suche werden dann alle Teilgraphen des durchsuchten Korpusgraphen gefunden, die dieser Beschreibung entsprechen.
Es stehen die Klauseln \texttt{node}, \texttt{nodes}, \texttt{edge}, \texttt{link}, \texttt{text}, \texttt{meta}, \texttt{cond} und \texttt{def} zur Verfügung, wobei eine Anfrage mindestens eine \texttt{node}- oder \texttt{text}-Klausel oder eine unverbundene \texttt{edge}-Klausel enthalten muß. Die Klauseln werden in den folgenden Abschnitten im einzelnen beschrieben.

Die einzelnen Klauseln werden in beliebiger Reihenfolge in jeweils eine eigene Zeile geschrieben; Einrückungen und Leerzeilen werden nicht interpretiert. Kommentare werden durch Voranstellen eines Doppelkreuzes \texttt{\#} markiert.



\subsubsection{\texttt{node}}\label{node}

Die \texttt{node}-Klausel beschreibt einen Knoten, der im Graphfragment genau einmal vorkommen soll. Die Klausel besteht aus dem Schlüsselwort \texttt{node}, einer optionalen ID und einer Attributbeschreibung.

Die ID besteht aus einem \texttt{@} gefolgt von einer Zeichenkette, die aus alphanumerischen Zeichen und dem Unterstrich besteht. Unter der ID kann der Knoten in anderen Teilen der Suchanfrage referenziert werden.

Die Attributbeschreibung besteht aus Schlüssel-Wert-Paaren der Form \texttt{schlüssel:""wert}, die mit den logischen Operatoren \texttt{!} für „nicht“, \texttt{\&} für „und“ und \texttt{|} für „oder“ (Bindungsstärke: \texttt{!} > \texttt{\&} > \texttt{|}) sowie Klammerung mit runden Klammern verknüpft sind. Als Abkürzung für Disjunktionen von Schlüssel-Wert-Paaren mit dem gleichen Schlüssel steht die Form \texttt{schlüssel:wert1|wert2|...|wertn} zur Verfügung.

Der Schlüssel eines Schlüssel-Wert-Paares kann entweder als einfache Zeichenkette angegeben werden, wenn er keines der in der Abfragesprache verwendeten Steuerzeichen (\texttt{␣():!\&\quo/?+*\{\}@\#\^{}}) enthält, oder als Zeichenkette in doppelten Anführungsstrichen (\texttt{{\quo}xyz\quo}), die beliebige Zeichen enthalten darf (doppelte Anführungsstriche müssen mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}).

\phantomsection\label{zeichenketten}Die Werte der Schlüssel-Wert-Paare sind Zeichenketten, die auf dreierlei Art und Weise angegeben werden können. Die erste Variante sind einfache umarkierte Zeichenketten, die alle Zeichen außer den in der Abfragesprache verwendeten Steuerzeichen (\texttt{␣():!\&\quo/?+*\{\}@\#\^{}}) enthalten dürfen. Diese Zeichenketten werden bei der Suche ohne Beachtung von Groß- und Kleinschreibung verglichen.
Die zweite Variante sind Zeichenketten in doppelten Anführungsstrichen (\texttt{{\quo}xyz\quo}). Diese dürfen beliebige Zeichen enthalten (doppelte Anführungsstriche müssen mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}) und werden unter Beachtung von Groß- und Kleinschreibung verglichen. 
Die dritte Variante sind reguläre Ausdrücke. Diese werden in Schrägstrichen angegeben (\texttt{/x.z/} und gehorchen den Regeln für reguläre Ausdrücke in Ruby (siehe \texttt{http://www.ruby-doc.org/""core/""Regexp.html}). Die regulären Ausdrücke sind nicht verankert; um den Ausdruck am Anfang bzw. Ende einer Zeichenkette zu verankern müssen also \texttt{\^} bzw. \texttt{\$} verwendet werden; eine beliebige Zeichenkette kann mit \texttt{//} gefunden werden.

Wie eine Attributbeschreibung kann das Schlüsselwort \texttt{token} verwendet werden, welches prüft, ob es sich beim Knoten um ein Token handelt.

Des weiteren kann die Attributbeschreibung Kriterien für ein- und ausgehende Kanten enthalten. Diese bestehen aus dem Schlüsselwort \texttt{in} bzw. \texttt{out}, einer optionalen Attributbeschreibung in runden Klammern und einem optionalen Quantor. Der Operator \texttt{in} bzw. \texttt{out} findet alle ein- bzw. ausgehenden Kanten mit den angegebenen Attributen, der Quantor gibt an, wieviele Kanten der spezifizierten Art vorhanden sein dürfen und ist (syntaktisch) wie bei regulären Ausdrücken definiert: \texttt{\{m,n\}} für mindestens m-mal, höchstens n-mal; bei Auslassung der ersten Zahl wird 0 angenommen, bei Auslassung der zweiten unendlich. \texttt{\{n\}} steht für genau n mal. Des weiteren gibt es die Abkürzungen \texttt{?} für \texttt{\{0,1\}}, \texttt{*} für \texttt{\{0,\}} und \texttt{+} für \texttt{\{1,\}}.
Anders als von regulären Ausdrücken gewohnt (und anders als beim Auftreten von Quantoren in anderen Kontexten der GraphAnno-Abfragesprache), wird das Fehlen eines Quantors hier als \texttt{\{1,\}} interpretiert.

Für die Kanten wiederum können – zusätzlich zu den einfachen Attributen – über die Schlüsselwörter \texttt{start} bzw. \texttt{end} und Attributbeschreibungen in runden Klammern auch Eigenschaften des Start- bzw. Zielknoten angegeben werden.

Ähnlich wie \texttt{in} und \texttt{out} funktioniert \texttt{link}, jedoch werden damit nicht nur ein- und ausgehenden Kanten abgefragt, sondern (ggf.) komplexere Verbindungen zu anderen Knoten. Wie diese Verbindungen spezifiziert werden, ist in \ref{link} beschrieben. Auch für \texttt{link} gelten die Regeln für Quantoren, wie für \texttt{in} und \texttt{out} beschrieben.

\paragraph*{Die \texttt{node}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
node-klausel    =   "node" id? " " knotenattribute
id              =   "@" alphanumerisches_zeichen+
knotenattribute =   knotenattribute " & " knotenattribute
                    knotenattribute " | " knotenattribute
                    "!" knotenattribute
                    "(" knotenattribute ")"
                    attribut
                    kantenkriterium
                    "token"
attribut        =   zeichenkette ":" attributwert ("|" attributwert)*
zeichenkette    =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """
attributwert    =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """
                    "/" regulärer_ausdruck "/"
kantenkriterium =   "in" ("(" kantenattribute ")")? quantor?
                    "out" ("(" kantenattribute ")")? quantor?
                    "link" ("(" verbindung ")") quantor?
quantor         =   "?" | "*" | "+" | "{" zahl? ("," zahl?) "}"
kantenattribute =   kantenattribute " & " kantenattribute
                    kantenattribute " | " kantenattribute
                    "!" kantenattribute
                    "(" kantenattribute ")"
                    attribut
                    knotenkriterium
knotenkriterium =   "start" ("(" knotenattribute ")")
                    "end" ("(" knotenattribute ")")
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Knoten, die die Kategorie S oder VP haben und keine Token sind:\\
	{\tt node cat:S|VP \& !token}
	\item Suche alle Knoten, die von der Kategorie VP sind oder Token mit dem pos-Wert verb:\\
	{\tt node cat:VP | token \& pos:verb}
	\item Suche alle Knoten der Kategorie S, die mindestens zwei ausgehende AUX-Kanten haben:\\
	{\tt node cat:S \& out(cat:AUX)\{2,\}}
	\item Suche alle Knoten der Kategorie S, die mindestens einen Knoten mit dem pos-Wert pro dominieren:\\
	{\tt node cat:S \& out(end(pos:pro))}
\end{itemize}



\subsubsection{\texttt{nodes}}

Die \texttt{nodes}-Klausel beschreibt eine Menge von Knoten, die im Graphfragment enthalten sein sollen – wenn die Menge nur als Ziel einer \texttt{link}- oder \texttt{edge}-Klausel auftritt, kann die Menge jedoch auch leer sein. Die \texttt{nodes}-Klausel hat, abgesehen vom Schlüsselwort,  die gleiche Syntax wie die \texttt{node}-Klausel.

\paragraph*{Die \texttt{nodes}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
nodes-klausel    =   "nodes" id? " " knotenattribute
\end{lstlisting}
\end{framed}






\subsubsection{\texttt{edge}}\label{edge}

Die \texttt{edge}-Klausel hat zwei Anwendungen. Zum einen kann sie verwendet werden, um einzelne Kanten zu suchen. Dann besteht die Klausel aus dem Schlüsselwort \texttt{edge}, einer optionalen ID, unter die die Kante in der Ausgabe referenziert werden kann, und einer Attributbeschreibung für Kanten wie in \ref{node} beschrieben. Zum anderen dient die \texttt{edge}-Klausel dazu, anzugeben, daß zwischen zwei Knoten bzw. Knotenmengen des Graphfragments (mit \texttt{node} bzw. \texttt{nodes} spezifiziert) eine Kante mit den angegebenen Eigenschaften existieren soll. Dazu werden nach der (optionalen) ID der Kante die IDs von Start und Ziel der Kante angegeben.

Durch die optionale ID und die verschiedenen Verwendungsmöglichkeiten kann das Schlüsselwort \texttt{edge} von null bis drei IDs gefolgt sein. Die Interpretation dieser IDs ergibt sich aus ihrer Anzahl und der Reihenfolge. Eine ID: ID der Kante selber; zwei IDs: Start und Ziel der Kante; drei IDs: ID der Kante, Start und Ziel.


\paragraph*{Die \texttt{edge}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
edge-klausel    =   "edge" id? (id id)? " " kantenattribute
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Kanten die die syntaktische Funktion Subjekt anzeigen:\\
	{\tt edge synfunc:subj}
	\item Suche alle Knoten der Kategorie S, jeweils mit der Menge von Knoten der Kategorie NP, die über eine Kante der Kategorie S, A oder P verbunden sind:\\
	{\tt
	node @s  cat:S\\[-.4ex]
	nodes @np cat:NP\\[-.4ex]
	edge @s@np cat:S|A|P
	}
\end{itemize}







\subsubsection{\texttt{link}}\label{link}

Die \texttt{link}-Klausel beschreibt, wie zwei Knoten oder Knotenmengen des Teilgraphen verbunden sein sollen. Dabei kann als Verbindung eine Kette von Knoten und Kanten ähnlich einem regulären Ausdruck beschrieben werden.
Die \texttt{link}-Klausel besteht aus den Schlüsselwort \texttt{link}, der Angabe von Start- und Endknoten der Verbindung in der Form \texttt{@id1@id2} und der Beschreibung der Verbindung.

Die Verbindungsbeschreibung besteht aus einer Abfolge von \texttt{edge}- und \texttt{node}-""Elementen. Diese bestehen aus dem jeweiligen Schlüsselwort (\texttt{edge} bzw. \texttt{node}) und optional einer Angabe von Bedingungen, die das Element erfüllen muß, in runden Klammern. Dabei handelt es sich um eine Attributbeschreibung wie oben für \texttt{node} angegeben. Gefolgt werden kann die Elementbeschreibung von einer ID, unter der die gefundenen Elemente in der Ausgabe (nicht in der Suche!) referenziert werden können.

Für Alternativen steht der Operator \texttt{|} „oder“ zur Verfügung; bezüglich der Bindungsstärke steht er unter der Abfolge. Klammerung ist mit runden Klammern möglich. Des weiteren können Quantoren verwendet werden. Diese werden weder als gierig noch als genügsam interpretiert; alle  passenden Verbindungen werden gefunden und als separate Treffer gewertet.

Eine Verbindung besteht – der Natur eines Graphen entsprechend – stets aus einem Wechsel von Knoten und Kanten (beginnend und endend mit jeweils einer Kante). Bei der Angabe von einer Verbindung darf jedoch darauf verzichtet werden, stets Knoten und Kanten im Wechsel anzugeben; nur die erste Kante darf nicht ausgelassen werden. Stehen zwei Elemente des gleichen Typs (also \texttt{edge} oder \texttt{node}) hintereinander, so wird bei der Suche dazwischen ein unspezifiziertes Element des jeweils anderen Typs eingeschoben. Die Verbindungsbeschreibung \texttt{edge(a:b) edge(c:d)} beispielsweise findet eine Kante mit dem Attribut \texttt{a:b}, dann einen beliebigen Knoten und dann eine Kante mit dem Attribut \texttt{c:d}.

Wird \texttt{link} als Knotenattribut (z.B. in einer \texttt{node}-Klausel) verwendet, fällt die Angabe von Start- und Endknoten weg. Startknoten ist dann der gesuchte Knoten, Endknoten der letzte in der Verbindung spezifiziert Knoten bzw., wenn die Verbindungsbeschreibung mit einer Kante endet, ein Knoten mit beliebigen Eigenschaften.


\paragraph*{Die \texttt{link}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
link-klausel    =   "link" id id " " verbindung
verbindung      =   verbindung " " verbindung
                    verbindung "|" verbindung
                    "(" verbindung ")"
                    verbindung quantor
                    "edge" ("(" kantenattribute ")")? id?
                    "node" ("(" knotenattribute ")")? id?
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Graphfragmente, die aus einem Knoten der Kategorie P und einem der Kategorie S bestehen, wobei ersterer letzteren über eine Kante der Kategorie EX dominiert:\\
	{\tt
	node @p cat:P\\[-.4ex]
	node @s cat:S\\[-.4ex]
	link @p@s edge(cat:EX)
	}
	\item Suche einen Knoten der Kategorie S, alle Knoten der Kategorie NP, die dieser dominiert, und alle Token, die von den NPn dominiert werden:\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @vpn cat:NP\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@npn edge+\\[-.4ex]
	link @npn@tok edge+
	}
	\item Suche einen Knoten der Kategorie S und alle Token, die von diesem über einen NP-Knoten dominiert werden (bis auf die IDs äquivalent zum vorigen Beispiel):\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@tok edge+ node(cat:NP) edge+
	}
\end{itemize}




\subsubsection{\texttt{text}}

Die \texttt{text}-Klausel dient dazu, eine Abfolge von Token-Knoten zu finden. Dabei ermöglicht die Textsuche sowohl die Suche nach reinem Text als auch nach weiteren Attributen der Token-Knoten.
Die \texttt{text}-Klausel besteht aus dem Schlüsselwort \texttt{text}, einer optionalen ID und der Beschreibung eines Textfragments, das mit \texttt{\^{}s} am Anfang bzw. Ende des Textes eines Satzes verankert werden kann.

Die Beschreibung des Textfragments besteht aus einer Abfolge von Wortbeschreibungen, die aus einer Zeichenkette, die den Tokentext beschreibt (drei Varianten wie oben unter \texttt{node} für die Werte in Schlüssel-Wert-Paaren beschrieben), und einer optionalen Angabe von Attributen (Attributebeschreibung wie oben unter \texttt{node}) in runden Klammern zusammengesetzt ist.
Für die Beschreibung des Textfragments stehen wie bei der Verbindungsbeschreibung der Operator \texttt{|} für „oder“ (Bindungsstärke schwächer als die der Sequenz), Klammerung und Quantoren zur Verfügung, wobei die Quantoren bei der Textsuche genügsam sind. Zusätzlich kann Textfragmenten eine ID nachgestellt werden, um die gefundenen Knoten in anderen Klauseln zu referenzieren. Quantoren und IDs haben eine höhere Bindungsstärke als Sequenz und Disjunktion; die Reihenfolge von Quantor und ID hinter dem selben Textfragment ist beliebig. Die optionale ID nach dem Schlüsselwort gilt für alle Knoten der \texttt{text}-Klausel. Das gesuchte Textfragment kann mit \texttt{\^{}s} am Beginn bzw. Ende eines Textes (Text eines Satzes) verankert werden.

\paragraph*{Die \texttt{text}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
text-klausel    =   "text" id? " " "^s"? textfragment "^s"?
textfragment    =   textfragment " " textfragment
                    textfragment "|" textfragment
                    "(" textfragment ")"
                    textfragment quantor
                    textfragment id
                    wort
wort            =   attributwert ("(" knotenattribute ")")?
\end{lstlisting}
\end{framed}

\paragraph*{Beispiel:}
\begin{itemize}
	\item Suche alle Sätze, in denen das Wort das Nomen „Säge“ an dritter Stelle steht:\\
	{\tt
	text \^{}s //\{2,2\} Säge(pos:n)
	}
	\item Suche zwei Vorkommen von „er“, die von einer beliebigen Anzahl Wörter getrennt sind, wobei das erste „er“ und alle folgenden Wörter bis zum zweiten „er“ von einem Knoten vom cat S dominiert werden:\\
	{\tt
	node @s cat:S\\
	text (er //*)@t er\\
	link @s@t edge*
	}
\end{itemize}



\subsubsection{\texttt{meta}}

Die \texttt{meta}-Klausel schränkt die Menge der zu durchsuchenden Sätze ein. Über diese Klausel können Eigenschaften angegeben werden, die der Satznoten eines Satzes haben muß. Die Klausel besteht aus dem Schlüsselwort \texttt{meta} und einer Attributbeschreibung wie oben unter \texttt{node} beschrieben.

\paragraph*{Die \texttt{meta}-Klausel in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
text-klausel    =   "meta " attribute
\end{lstlisting}
\end{framed}



\subsubsection{\texttt{cond}}\label{cond}

Die \texttt{cond}-Klausel gibt Bedingung an, die das Graphfragment erfüllen muß und wirkt wie ein Filter. Die Klausel besteht aus dem Schlüsselwort \texttt{cond} und der Bedingung in Ruby-Kode. Die Knoten und Knotenmengen werden dabei durch die vergebenen IDs referenziert. Bei der Referenzierung ist zu beachten, daß es sich bei den mit \texttt{node} und \texttt{edge} gefundenen Knoten und Kanten um einzelne Elemente, bei den mit \texttt{nodes}, \texttt{text} und \texttt{link} gefundenen Knoten und Kanten hingegen um Arrays von Elementen handelt.

Auf die Attribute der Knoten wird in der Form \texttt{['schlüssel']} zugegriffen; für die Attribute \texttt{token} und \texttt{cat} stehen Abkürzungen der Form \texttt{.token} und \texttt{.cat} zur Verfügung. Über die Methode \texttt{.sentence} kann auf den Satznoten des Satzes, zu dem das Element gehört, zugegriffen werden. Bei der Verwendung von Attributwerten ist zu beachten, daß es sich bei diesen stets um Zeichenketten handelt; sollen sie als Zahlen behandelt werden, müssen sie mit \texttt{.to\_i} bzw. \texttt{.to\_f} umgewandelt werden.


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche zwei S-Knoten, die über eine ad-Kante verbunden sind und den gleichen Wert für tns haben:\\
	{\tt
	node @s1 cat:S\\[-.4ex]
	node @s2 cat:S\\[-.4ex]
	link @s1@s2 cat:ad\\[-.4ex]
	cond @s1['tns'] == @s2['tns']
	}
	\item Suche alle S-Knoten, die mindestens drei Token dominieren:\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@tok edge+\\[-.4ex]
	cond @tok.length >= 3
	}
\end{itemize}


\subsubsection{\texttt{def}}\label{def}

Mit \texttt{def} besteht die Möglichkeit, für die Suche Makros zu definieren. Dabei wird ein Name angegeben, unter dem das Makro in den Suchklauseln angesprochen werden kann, und eine Attribut- oder Verbindungsbeschreibung, die durch den Namen vertreten wird. Die Attribut-/Verbindungsbeschreibung ist aufgebaut wie für \texttt{node} und \texttt{link} in \ref{node} bzw. \ref{link} beschrieben.

Es ist zu beachten, daß ein Makro quasi automatisch geklammert wird, also stets zuerst ausgewertet wird. Nehmen wir beispielsweise an, man definiert ein Makro als \texttt{cat:S | cat:VP} wie unten im Beispiel und kombiniert es durch den Operator \texttt{\&} mit einer weiteren Bedingung – \texttt{tns:prs} wie beim zweiten Knoten im Beispiel. Dann wird dies nicht als \texttt{cat:S | cat:VP \& tns:prs} ausgewertet, in welchem Falle das \texttt{\&} Präzedenz über das \texttt{|} nähme, sondern als \texttt{(cat:S | cat:VP) \& tns:prs}.

\paragraph*{Die Makrodefinition \texttt{def} in modifizierter BNF:}
~
\begin{framed}
\begin{lstlisting}
makrodefinition =   "def " name " " makro
makro           =   kantenattribute
                    knotenattribute
                    verbindung
name            =   alphanumerisches_zeichen+
\end{lstlisting}
%\begin{lstlisting}
%makrodefinition =   "def " name " " (kantenattribute | knotenattribute)
%name            =   alphanumerisches_zeichen+
%\end{lstlisting}
\end{framed}


\paragraph*{Beispiel:}
\begin{itemize}
	\item Suche zwei Knoten mit \texttt{cat:S} oder \texttt{cat:VP}, die über eine Kante verbunden sind, und von denen der zweite im Präsens steht:\\
	{\tt
	def svp cat:S | cat:VP\\[-.4ex]
	node @s1 svp\\[-.4ex]
	node @s2 svp \& tns:prs\\[-.4ex]
	edge @s1@s2\\[-.4ex]
	}
%\begin{itemize}
%	\item Suche zwei Knoten mit \texttt{lemma:cum} und \texttt{pos:G-}, die über eine Kante verbunden sind, und von denen einer ein Token ist:\\
%	{\tt
%	def cum lemma:cum \& pos:G-\\[-.4ex]
%	node @s1 cum\\[-.4ex]
%	node @s2 cum \& token\\[-.4ex]
%	edge @s1@s2\\[-.4ex]
%	}
\end{itemize}






\subsection{Datenexport}

Die GraphAnno-Abfragesprache biete auch Funktionalität zum Exportieren von Suchergebnissen als CSV-Dateien an. 
Mit den nachfolgen beschriebenen Klauseln kann angegeben werden, wie Infomationen der in einer zuvor durchgeführten Suche gefundenen Teilgraphen ausgegeben werden sollen.
Die Daten jedes gefundenen Teilgraphen werden in eine Zeile der CSV-Datei geschrieben, mit \texttt{sort} können die Ergebnisse sortiert werden, mit \texttt{col} wird angegeben, welche Spalten mit welchen Werten angelegt werden sollen. Als erste Spalte wird stets eine fortlaufende Numerierung der Ergebnisse mit ausgegeben.

\subsubsection{\texttt{sort}}

Die \texttt{sort}-Klausel dient dazu, die Ausgabe der gefundenen Teilgraphen zu sortieren. Es können mehrere \texttt{sort}-Klauseln angegeben werden, wobei weiter unten angegeben Klauseln nur ausgewertet werden, wenn  weiter oben angegebenen Klauseln keine Reihenfolge zwischen zwei Teilgraphen ergeben. 
Eine \texttt{sort}-Klausel wird in Ruby-Kode formuliert und muß einen Wert ergeben, der für die Sortierung verglichen werden soll. Wie bei \texttt{cond} werden die gefundenen Knoten und Kanten über die in der Suche vergebenen IDs referenziert. Bei Verwendung von Attributwerten ist zu beachten, daß es sich bei diesen stets um Zeichenketten handelt; sollen sie als Zahlen verglichen werden, müssen sie mit \texttt{.to\_i} bzw. \texttt{.to\_f} umgewandelt werden.

\paragraph*{Beispiele:}
\begin{itemize}
	\item Sortiere die Ergebnisse nach Satznamen, bzw. nach Tokennummer (die Methode \texttt{.tokenid} gibt die Stelle des Tokens im Satz, beginnend mit 0, aus), wenn sie dem gleichen Satz angehören (durch die Suchanfrage sei gegeben: ein Token mit der ID \texttt{@t1}):\\
	{\tt
	sort @t1.sentence.name\\[-.4ex]
	sort @t1.tokenid\\[-.4ex]
	}
\end{itemize}



\subsubsection{\texttt{col}}

Jede \texttt{col}-Klausel steht für eine zu exportierende Spalte. Sie hat als ersten Parameter den Spaltentitel (der keine Leerzeichen enthalten darf), gefolgt von Ruby-Kode, der den auszugebenden Wert ergibt. Knoten und Kanten werden wie gehabt über ihre in der Suche vergebene ID referenziert, dabei ist zu beachten, daß es sich bei den mit \texttt{node} gefundenen Knoten um einzelne Knoten, bei den mit \texttt{nodes}, \texttt{text} und \texttt{link} gefundenen Knoten hingegen um Arrays von Knoten handelt.

Zugriff auf Attribute erfolgt wie unter \ref{cond} für \texttt{cond} beschrieben. Es gibt jedoch noch weitere für die Ausgabe nützliche Methoden: \texttt{.tokens} gibt die über syntaktische Kanten dominierten Token als Liste aus, \texttt{.text} deren Text als Zeichenkette (die einzelnen Tokentexte mit Leerzeichen getrennt). \texttt{.sentence\_tokens} gibt alle Token des Satzes, dem das Element angehört als Liste aus, \texttt{.sentence\_text} wiederum deren Text. \texttt{.position} gibt die Position eines Knotens als Durchschnitt der Positionen seiner dominierten Token aus.




}


\end{document}