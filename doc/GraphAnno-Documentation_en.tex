\documentclass[12pt]{scrartcl}
\usepackage{fontspec}
\usepackage{linguex}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{framed}
\usepackage{url}
\usepackage{xcolor}
\definecolor{darkblue}{rgb}{0,0,.5}
\usepackage[pdfpagemode=UseNone, colorlinks=true, allcolors=darkblue]{hyperref}

%\KOMAoptions{BCOR=16mm}
\KOMAoptions{DIV=10}


\setmainfont[WordSpace={1,1.15,1},Numbers=Proportional]{Linux Libertine O}
\setsansfont[Scale=MatchLowercase]{Linux Biolinum O}
\setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}

\textheight22.4cm % 42 Zeilen {\baselinestretch}{1.05}
% \voffset-4mm
% %\headsep4mm


%\parindent0pt
%\parsep0ex
\setkomafont{sectioning}{\rmfamily}%\bfseries}
%\setcounter{secnumdepth}{1}
%\setcounter{tocdepth}{2}
%\qtreecenterfalse
\frenchspacing

\let\origitemize\itemize
\def\itemize{\origitemize\itemsep-0.5ex}
\let\origenumerate\enumerate
\def\enumerate{\origenumerate\itemsep-0.5ex}
%\let\origdescr\description
%\def\description{\origdescr\itemsep-0.5ex}
\renewcommand{\labelitemi}{–}
\renewcommand{\labelitemii}{-}
\newcommand{\anf}[1]{‚#1‘}
\newcommand{\ti}{\char"223C}
\newcommand{\quo}{\char"0022}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
%\renewcommand{\bottomfraction}{1}

\lstset{basicstyle=\renewcommand{\baselinestretch}{1}\tt, aboveskip=0em, belowskip=0em, tabsize=4, xleftmargin=.5em}


\title{\LARGE GraphAnno\\ \large An annotation and query tool\\for graph-based linguistic annotations}
\author{Lennart Bierkandt\\\large Friedrich-Schiller-Universität Jena\\[-.2em]\large post@lennartbierkandt.de}
\date{Version of \today}


\renewcommand{\glt}{\vspace{-\Extopsep}}
\renewcommand{\firstrefdash}{}
\newcommand{\re}{\vspace{-.33\Extopsep}} %{-1.33\Extopsep} für normalen Zeilenabstand bei \ex. mit \gll, 0.66 ohne \gll
\newcommand{\regll}{\vspace{-\Extopsep}\gll}
\let\eachwordtwo=\glosse
\glossglue = 5pt plus 2pt minus 2pt


\newenvironment{figurel}{\begin{figure}[htb]\vskip 2ex}{\end{figure}}
\newenvironment{tablel}{\begin{table}[htb]\vskip 2ex}{\end{table}}

\newenvironment{anmerkung}{\par{\ }\par\sf\color{black!60}\noindent\textbf{Remark:}\par}{\newline\par}

\newcommand{\kommentar}[1]{}

\setlength{\abovecaptionskip}{0ex}








\begin{document}

\maketitle

\renewcommand{\baselinestretch}{1.05}\normalsize

\tableofcontents


\section{The annotation graph}

\subsection{Graph format}

A graph in GraphAnno consists of a set of nodes and directed edges.
Nodes and edges bear attributes in the form of key-value pairs, that are used for the linguistic annotation as well as the structuring and visualization of the graph.
There are some attributes – like the attribute \texttt{type}, that differentiates the types of nodes and edges (annotation nodes, tokens, sentence nodes; annotation edges, ordering edges, section edges) – that serve the internal representation of the graph and are not edited directly.
Under the key \texttt{attr}, however, there is a group of key-value pairs which serve the linguistic annotations and the representation of layers and which are edited by the user directly.
They will be called \textit{annotation attributes} in the following.

The graph in GraphAnno is segmented in sentences – units that that are used for structuring and displaying the corpus, but that do not necessarily correspond to real sentences (how ever these may be defined).
There is a sentence node (bearing the attribute \texttt{type:s}) for every sentence, that bears information concerning the whole sentence.
This includes, e.g., source, medium, speaker or the like.
The annotations of this node is displayed in the light grey area below the sentence graph and under the text of the sentence (blue font) in black font.
The information to which sentence a node of the graph belongs is represented by an (invisible) edge with \texttt{type:s} that links the node in question to the sentence node.
Edges are not linked to a sentence node; their affiliation follows from the affiliation of their start and end nodes.

Token nodes are characterized by the attribute \texttt{type:t} and they carry the annotation attribute \texttt{token} with the token text as value.
The order of the tokens of a sentence (as well as the sentence nodes themselves) is defined by ordering edges (with \texttt{type:o}) that link each node to its successor.
These edges are needed for the correct visualization and for traversal; the are, however, not displayed and cannot be manipulated directly.

Among the annotation attributes, nodes and edges may bear the \texttt{cat} attribute, that has no special meaning for the graph, but which is desplayed prominently on top of the other annotations and without the key.
Nodes and edges show numbers like \texttt{t23} for tokens, \texttt{n23} for other nodes and \texttt{e23} for edges, that are used for referencing the elements in annotation commands.
These numbers are not stored in the graph model but generated dynamically each time the displayed graph is rendered.

GraphAnno also provides the possibility to assign nodes and edges to different layers.
The fact that a node or edge is affiliated to a certain layer is represented by that element bearing an annotation (among the annotation attributes) with the key corresponding to the layer and the value \texttt{t} (for \textit{true}).
This representation allows for elements to belong to more than one layer, with the consequence that layers my overlap in an arbitrary manner.
Nodes and edges of different layers may be displayed in different colors and aligned in different ways (hierachically or horizontally).
Tokens do not belong to any layer; they are displayed in black by default.



\subsection{Configuration}\label{konfiguration}

\subsubsection{Layers and visualization}\label{ebenenkonfiguration}

The window for configuration of the layers of the currently loaded graph and its visualization is opened with the commmand line command \texttt{config}.

In the section \textit{general settings}, you can configure the settings for nodes and edges that do not belong to any layer.\footnote{Depending on the browser you use, the color fields are displayed as color picker or as simple text field. In the latter case, you have to provide the color as hexadecimal RGB value: A hash (\texttt{\#}) followed by three two-digit hexadecimal numbers for red, green and blue, respectively. \texttt{\#000000}, e.g., stands for black, \texttt{\#ffffff} for white, \texttt{\#ff0000} for light red etc.}
\textit{Default color} applies to all nodes and edges that are not tokens and that do not belong to any layer, \textit{token color} applies to tokens, \textit{found color} is used for the highlighting of nodes and edges found in a search, and \textit{filtered color} for elements that are filtered out by the filter function.
The setting for \textit{edge weight} affects the layout of the displayed graph and shows its effect only when edges with different weight are present (details will follow in the next paragraph).

In the section \textit{layers}, you can configure the layers of the graph.
The \textit{name} is an arbitrary label for the layer, that will be shown in the dropdown field for the layer selection.
\textit{Attribute} is the attribute that will be set to \texttt{t} for elements that belong to the layer in question.
The \textit{shortcut} is an identifier that can be used for the annotation of elements (cf. \ref{befehl-n} or \ref{befehl-l}); this shortcut may only consist of alphanumeric characters and underscores and must not have the same structure as element references (i.e., \texttt{t}, \texttt{n} or \texttt{e} followed by a number, or  \texttt{m}; cf. \ref{befehl-a}).
\textit{Color} means the color that is used for displaying the elements of the layer; \textit{edge weight} is the weight of the layer’s edges.
The heigher this value (integer values), the shorter the rendering algorithm will try to make the edges.
When you create two layers, one with a high edge weight and one with a low edge weight, the graph will be rendered such that the graph of the first layer is as compact as possible; the elements of the second layer will be placed in a way that they distort the first layer only to a low degree.
If you enter \texttt{0} as edge weight, the edges will not enforce a hierachy between the nodes of that layer (otherwise, the start node of an edge is always placed higher than the end node).
If a negative value is entered, all nodes of that layer are displayed horizontally on one tier.

The section \textit{layer combinations} contains the settings for elements that belong to multiple layers.
Via the checkboxes under \textit{attributes} you determine, to which layers an element has to belong in order to be subject to the definition of the combination in question.
The other settings work like those described for the \textit{layers}, and for those elements that belong to the layer combination, they override the values given for the single layers.

Under \textit{search makros} you can enter predefined graph-specific search makros as described in Section \ref{def}.
These makros are then available for search queries in the graph.
In the search makros text area, the definitions (\texttt{def ...}) have to be enterd each on its own line.

\subsubsection{Permitted annotations / tagset}\label{erlaubteannotationen}

In the window open by the command \texttt{tagset}, you can specify which annotation are permitted for the nodes and edges of the graph, i.e., you can define the graph-specific tagset.
Only the keys and values defined here are permitted for the annotation of elements, illicit input is answered with an error message.
Already existing annotations are not affected by changes of the permitted keys and values.

If you do not specify any keys and values, all annotations are permitted.
If you specify keys, only these keys are allowed for annotations.
If you leave the value field for a key empty, then all values are permitted for this key.
If you want to restrict the possible values for a key, you may enter these into the value field of the key in question, separated by spaces.

The notation of the values is subject to the same rules as in the query language (cf. Section \ref{node}, p.\,\pageref{zeichenketten}):
Simple values are entered without further markup; if a value contains special characters (see p.\,\pageref{zeichenketten}) it has to be enclosed in double quotes (\texttt{\quo...\quo}).
Additionally – just like in the query language (p.\,\pageref{zeichenketten}) – you may use regular expressions, which are enclosed in slashes (\texttt{/.../}).
In this case the regular expressions are anchored, i.e. an annotation value has to match the whole regular expression in order to be permitted.

\subsubsection{Annotation makros}\label{annotationsmakros}

For a graph you save annotation makros, that facilitate the annotation with frquently needed attribute combinations.
With the command \texttt{makros} you open a window where you can define these makros.
In the fields on the left you enter the shortcut for your makro (it has to consist of alphanumeric characters including the underscore, and it should not have the form of an element reference or be identical to a layer shortcut, cf. Section \ref{ebenenkonfiguration}); in the corresponding field on the right you enter the desired annotations for your makro.
For these annotations you must use the same syntax as in the annotation commands, i.e. a set of attributes in the form \texttt{key:value}, separated by spaces (see Section \ref{befehl-n} for details).

\subsubsection{Metadata}

Additionally to the configuration of layers, visualization, makros and permitted annotations, you may save metadata for a graph as key-value pairs.
The command \texttt{metadata} opens the window, where you can enter an arbitrary number of keys with a text as corresponding value.


\section{Keyboard shortcuts}

In GraphAnno most of the functions related to navigation and display are controlled by keybord shortcuts.
The following is a table of the available shortcuts:

\begin{center}
	\begin{tabular*}{\textwidth}{ll}
		\toprule
		Shortcut & Function \\
		\midrule
		Navigation & \\
		\midrule
			Alt + ←/→ & previous/next sentence\\
			Alt + Home/End & first/last sentence \\
		\midrule
		Graph & \\
		\midrule
			Ctrl + Shift + −/+ & scale down/up graph\\
			Ctrl + Shift + 0 & zoom to fit (wrt. height) \\
			Ctrl + Shift + arrows & move graph\\
			Ctrl + Shift + Home/End & go to left/right edge of graph\\
			Ctrl + Shift + Page up/Page down& go to upper/lower edge of graph\\
			F4 & toggle element references\\
		\midrule
		Window & \\
		\midrule
			F1 & show/hide help window \\
			F2 & show/hide text and sentence annotations\\
			F6 & show/hide filter window\\
			F7 & show/hide search window\\
			F8 & show/hide change log window\\
		\bottomrule
	\end{tabular*}
\end{center}




\section{Command line commands}

\subsection{Data and navigation}

\subsubsection{Load file: \texttt{load}}

With the command \texttt{load} you load a graph file inte the work space.
By default, the file will be loaded from the from the \texttt{data} directory located in the GraphAnno main directory; but you can also provide a path (directories are separated by the normal slash \texttt{/} on all operating systems).
If the path does not start with a slash, it will be interpreted relative to the \texttt{data} directory, if it starts with a slash, it will be interpreted as an absolute path (in the partition GraphAnno is installed in if you are working on a Windows systems).
Provide the file name with or without the extension \texttt{.json}; the path has to be enclosed in double quotes (\texttt{\quo...\quo}) if it contains spaces.

Before loading, the work space is cleared from all data.
So, changes that were not saved explicitly (using the command \texttt{save}) are lost.
The name of the loaded file is shown next to the input line on the bottom of the user interface.


\subsubsection{Load file: \texttt{add}}

Just like the command \texttt{load}, the command \texttt{add} loads a file into the work space (specify the file as described for \texttt{load}).
The difference is that the work space is not cleared – the new file is added and the new sentences are appended to the existing ones.
After adding the file no file is shown as loaded next to the input line and the files cannot be saved separately anymore.


\subsubsection{Save file: \texttt{save}}

The command \texttt{save} saves the work space to a GraphAnno file in the \texttt{data} directory.
The file name has to be entered in the same way as with the command \texttt{load}.
If there is a filename indicated next to the input line, the work space can be saved to this file without specifying the file name.
Attention: no warning is issued when an existing file will be overwritten.


\subsubsection{Clear work space: \texttt{clear}}

The command \texttt{clear} clears the work space from all data.
Changes that were not saved are lost.
Next to the input line no file will be indicated anymore.


\subsubsection{Create new sentence: \texttt{ns}}\label{befehl-ns}

With the command \texttt{ns} – followed by one or more sentence names separated by spaces – you can create a new sentence.
The command creates sentence nodes with the corresponding \texttt{name} attribute; afterwards you are directed to the first newly created sentence.


\subsubsection{Delete sentence: \texttt{del}}

The command \texttt{del} deletes the current sentence including the sentence node.
If you enter one or more sentence names as arguments, it is not the current sentence that will be deleted but the sentences that bear one of the given names.
A further possibility is to enter a regular expression (in slashes); in that case, all sentences whose names match the given regular expression will be deleted.


\subsubsection{Set sentence: \texttt{s}}

In order to navigate from sentence to sentence, you may use (alternatively to keyboard shortcuts or the dropdown field) the command \texttt{s}, followed by the name of the sentence you want to change to.
You are then directed to the first sentence with the given name.


\subsubsection{Export graphics: \texttt{image}}

With the command \texttt{image}, you can export the graphic that GraphAnno is displaying for the current sentence.
The first argument is the desired format.
All formats supported by Graphviz are available, e.g. \texttt{dot}, \texttt{eps}, \texttt{pdf}, \texttt{png} or \texttt{svg}.
See under \url{http://www.graphviz.org/content/output-formats} for the complete list.
The second argument is the name of the new image file (without extension; put the name in double quotes if it contains spaces).
The image will be saved in GraphAnno’s \texttt{images} directory.


\subsubsection{Export corpus: \texttt{export}}\label{befehl-export}

Using the command \texttt{export}, you can export the contents of the work space as a corpus in another format.
The first argument is the format (at present the only fully functional format is \texttt{sql} for the import in GraphInspect; the format \texttt{paula} is theoretically available, but it is heavily restricted with respect to layers), the second argument is the name of the corpus to be saved.
For \texttt{paula} you can optionally specify the name of the corpus document to be created as third argument.
The exported corpus will be saved in GraphAnno’s \texttt{exports} directory.


\subsubsection{Import text: \texttt{import text}}

You can import texts with the command \texttt{import text}. After issuing the command, a window opens where you can enter the text and set the preferences for its processing.
The work space will be cleared before the text is imported (but not as soon as the window opens).
Changes that hadn’t been saved are lost and no file is indicated next to the input line anymore.

In the import window you can choose between two methods of entering your text:
You can upload a text file or you can paste it in the text area.
For the processing of the text there are two methods available, too.
For unedited text you may use the method “punkt segmenter”.
This method uses an automatic segmenter to split the text into sentences and tokens.
In order to process abbreviation etc. correctly, you need to specify the language of the text.

The second processing method is “regular expressions”; this method is made for preformatted texts.
First, you have to enter a string that will be used for segmenting the sentences.
The preset is \texttt{{\textbackslash}n} \footnote{\texttt{{\textbackslash}n} stands for a line break, \texttt{{\textbackslash}t} for a tab.} for a file in which every sentence starts on a new line.
The second string you have to enter a a regular expression that matches the tokens.
The preset here is \texttt{({\textbackslash}S+)}.
This stands for a sequence of non-spaces, so all words that are separated by spaces are matched as tokens.
The purpose of the parentheses is to save the matched string in the variable \texttt{\$1}, so it can be used in the next field.
The next field is for an annotation command (see \ref{befehl-a}) for the tokens, that uses the string matched by the regular expression in the preceding field.
The preset here is \texttt{token:\$1}.
That means that the string matched as token is used for the annotation of the token text.
Another example would be a text tagged for parts of speech, where the part of speech is appended to every word with an underscore.
In this case you would enter the regular expression \texttt{({\textbackslash}S+)\_({\textbackslash}S+)} and the annotation command \texttt{token:\$1 pos:\$2}.
The regular expression in this case finds two strings of non-spaces that are joined by an underscore; the strings are saved to the variables \texttt{\$1} (the word) and \texttt{\$2} (the POS tag).
In the annotation command these variables are used to annotate the token text and the \texttt{pos} attribute.


\subsubsection{Import Toolbox data: \texttt{import toolbox}}

Toolbox files can be imported using the command \texttt{import toolbox}.
This command opens a window in which you can choose the file to be imported and enter the format description.
The format description has to be in JSON format and consists of a list of a list of markers.
The lists are sorted according to their levels – the highest (\textit{record} level) first – and contain the markers that belong to the respective level (markers are entered without backslash).
The first marker of the first level (\texttt{ref} in the example below) will be used as record ID.
The marker whose line is to be used as token text is preceded by an asterisk.
Elements that lie below the token level will be joined and integrated into their respective tokens.

A format description for a toolbox file with three levels (record, word, morpheme) could look like this, e.g.:

\begin{verbatim}
  [["ref", "eng"], ["*gw"], ["mph", "ge", "ps"]]
\end{verbatim}

Like with the command \texttt{load}, the work space will be cleared when importing.
Changes that haven’t been saved will be lost; next to the input line no file will be indicated anymore.


\subsubsection{Export and import configuration: \texttt{export} and \texttt{import}}

The command \texttt{export} serves also for exporting graph configurations, that can be imported in other graphs using the command \texttt{import}.
As first argument you enter the type of the configuration to be exported or imported: \texttt{config} for layers and visualization configuration (see \ref{ebenenkonfiguration}), \texttt{tagset} for permitted annotations / tagset (see \ref{erlaubteannotationen}).
The second argument is the filename for the configuration file to be saved or to be imported (without file extension).
The exported file will be saved in a subdirectory – named like the configuration type – of the \texttt{exports} directory.
Attention: when importing, the existing configuration will be replaced completely.


\subsubsection{Edit configurations: \texttt{config}, \texttt{tagset}, \texttt{makros} and \texttt{metadata}}

These commands open the windows for the settings that were described in Section \ref{konfiguration}.
\texttt{config} for layers and visualization, \texttt{tagset} for permitted annotations / tagset, \texttt{makros} for annotation makros and \texttt{metadata} for metadata.



\subsection{Annotation commands}\label{annotationsbefehle}

GraphAnno’s annotation commands are designed to be entered quickly, so their syntax is rather compact:
they consist of a short command (often one letter only) and are followed by parameters seperated by spaces.

The commands require to be in a sentence, i.e., you have to create a sentence first (using the command \texttt{ns}, see \ref{befehl-ns}) if the work space is empty.


\subsubsection{New node: \texttt{n}}\label{befehl-n}

The command for creating a new node is \texttt{n}, followed by the attributes the new node is to bear as key-value pairs in the format \texttt{key:value}.
Key and value can be given either as simple string (if it doesn’t contain any of the special characters used in the annotation languages: \texttt{␣:\quo\#})\footnote{The symbol \texttt{␣} stands for the space.}) or as string in double quotes (\texttt{\quo...\quo}), that may contain any character (double quotes themselves have to be excaped with a backslash: \texttt{\textbackslash\quo}).

You can also use the shortcut from your previously defined annotation makros (see Section \ref{annotationsmakros}).
When you additionally enter attributes with keys present in the makro, these override the annotations defined in the makro.

Additionally, you can specify the layer to which the new node is to belong (if you don’t, it will belong to the layer set in the layer dropdown field).
For this purpose you use the shortcuts defined in the layer configuration (cf. Section \ref{ebenenkonfiguration}).
The use of these shortcuts also has the effect of a switch, insofar as it sets the layer for the following operations (like the command \texttt{l}, see \ref{befehl-l}).

\paragraph*{Command \texttt{n} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_n           =   "n " attributes
attributes          =   attributes " " attributes
                        attribute
                        annotation_shortcut
                        layer_shortcut
attribute           =   key string
key                 =   string ":"
string              =   character_not_special+
                        """ character* """
alnum               =   letter | digit | "_"
annotation_shortcut =   alnum+
layer_shortcut      =   alnum+
\end{lstlisting}
\end{framed}


\subsubsection{New edge: \texttt{e}}

The command for creating a new edge is \texttt{e}, followed by start and end node of the edge to be created and the attributes, it is to bear.
Like with \texttt{n}, the specification of a layer is possible.

\paragraph*{Command \texttt{e} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_e       =   "e " start_end " " start_end " " attributes
start_end       =   node_reference
                    token_reference
node_reference  =   "n" number
token_reference =   "t" number
\end{lstlisting}
\end{framed}


\subsubsection{Annotieren: \texttt{a}}\label{befehl-a}

The command for annotation elements is \texttt{a}, followed by the elements to be annotated and the attributes with which they are to be annotated (all given elements will be annotated with all given attributes; also layer shortcuts can be used).
The order of the elements and attributes is free.
You can also annotate sequences of elements of the same type (i.e., \texttt{n}, \texttt{e} or \texttt{t}) by entering the first and the last element joined by two dots.
E.g., when you enter \texttt{t3..t7}, all tokens from \texttt{t3} to \texttt{t7} will be annotated (you may enter the sequence also in the inverse order, i.e., \texttt{t7..t3}).

At the same time you can use the command \texttt{a} for deleting attributes.
In order to do so, enter the key to be deleted with colon, but without value.

\paragraph*{Command \texttt{a} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_a           =   "a " a_parameters
a_parameters        =   a_parameters " " a_parameters
                        element_reference
                        attributes
                        key
element_reference   =   node_reference
                        edge_reference
                        token_reference
                        meta_node_reference
                        element_sequence
edge_reference      =   "e" number
meta_node_reference =   "m"
element_sequence    =   node_sequence
                        token_sequence
                        edge_sequence
node_sequence       =   node_reference ".." node_reference
token_sequence      =   token_reference ".." token_reference
edge_sequence       =   edge_reference ".." edge_reference
\end{lstlisting}
\end{framed}


\subsubsection{Delete elements: \texttt{d}}

Elements are deleted with the command \texttt{d}, followed by the elements to be deleted.
If you delete nodes, the outgoing and ingoing edges are deleted as well.
If you delete a token node from the middle of a sentence, the adjacent tokens are joined automatically.

\paragraph*{Command \texttt{d} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_d       =   "d " d_parameters
d_parameters    =   d_parameters " " d_parameters
                    element_reference
\end{lstlisting}
\end{framed}


\subsubsection{Group nodes under new parent node: \texttt{g} oder \texttt{p}}

The grouping command \texttt{g} or \texttt{p} creates a new parent node for the given nodes.
I.e., the command creates a new node and edges that connect the new nodes to the nodes to be grouped.
The parameters of this command are the nodes to be grouped and the attributes the newly created node is to bear.
The order of nodes and attributes is irrelevant.
Like with the command \texttt{n}, a layer can be specified.

\paragraph*{Command \texttt{g}/\texttt{p} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_g           =   ("g " | "p ") g_parameters
g_parameters        =   g_parameters " " g_parameters
                        node_reference
                        token_reference
                        node_sequence
                        token_sequence
                        attribute
                        layer_shortcut
\end{lstlisting}
\end{framed}


\subsubsection{Append child node: \texttt{h} or \texttt{c}}

The command \texttt{h}/\texttt{c} works analogously to the command \texttt{g}/\texttt{p}, but instead of a parent node a new common child node is created.

\paragraph*{Command \texttt{h}/\texttt{c} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_h           =   ("h " | "c ") h_parameters
h_parameters        =   h_parameters " " h_parameters
                        node_reference
                        token_reference
                        node_sequence
                        token_sequence
                        attribute
                        layer_shortcut
\end{lstlisting}
\end{framed}


\subsubsection{Insert node into edge: \texttt{ni}}

The command \texttt{ni} (\texttt{node insert}) allows you to insert a new node into an existing edge.
As parameters you specify the edge and the attributes for the new node.
A new node will be created, and the given edge will be replaced by two edges with the same annotations, that connect the start node of the original edge with the new node and the new node with the end node of the original edge.

If you specify more than one edge, a new node will be inserted into each of them

\paragraph*{Command \texttt{ni} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_ni          =   "ni " ni_parameters
ni_parameters       =   ni_parameters " " ni_parameters
                        edge_reference
                        attributes
                        layer_shortcut
\end{lstlisting}
\end{framed}


\subsubsection{Delete node but preserve connections: \texttt{di} und \texttt{do}}

If you want to delete a node but preserve the connections between parent node(s) and child node(s) of the deleted node, you can use the commands \texttt{di} or \texttt{do}.
These commands delete the specified node and connect each child node to each mother node (this makes sense particularly in a tree-like structure where there is one parent node and many child nodes).
\texttt{di} (\textit{delete ingoing}) deletes the ingoing edge(s), \texttt{do} (\textit{delete outgoing}) deletes the outgoing edge(s).

\paragraph*{Commands \texttt{di} and \texttt{do} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_di_do       =   "di " node_reference+
                        "do " node_reference+
\end{lstlisting}
\end{framed}


\subsubsection{Tokenize: \texttt{t}, \texttt{tb}, \texttt{ta}}

For creating tokens there are the commands \texttt{t}, \texttt{tb} and \texttt{ta}.
The arguments for these commands are a list of words, separated by spaces.
These words are inserted as tokens into the current sentence.
If the sentence already contains tokens, the command \texttt{t} appends the new ones.
\texttt{tb} (\texttt{tokenize before}) and \texttt{ta} (\texttt{tokenize after}) take a token as their first argument and insert the new tokens before or after, respectively.

The words can be given as bare strings, or, if they contain control characters (\texttt{␣:\quo\#}), as string in double quotes (\texttt{\quo...\quo}; double quotes inside the string have to be escape with a backslash: \texttt{\textbackslash\quo}).

\paragraph*{Commands \texttt{t}, \texttt{tb}, \texttt{ta} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
befehl_t        =   "t " words
words           =   words " " words
                    word
word            =   non-control-character+
                    """ character* """

command_tb      =   "tb " token_reference " " words
command_ta      =   "ta " token_reference " " words
\end{lstlisting}
\end{framed}


\subsubsection{Undo/Redo: \texttt{undo} and \texttt{redo}}\label{befehl-undo}

You can undo previously issued annotation commands using the command \texttt{undo}.
These annotation commands include those commands that create or delete nodes or edges, as well as creating and deleting of sentences, but not work space-related commands such as \texttt{add} or \texttt{clear}.
A command you have undone can be redone with the command \texttt{redo}.
Undoing and redoing can be used multiple times; but if you issue an annotation command after having undone other commands, the undone commands cannot be redone (linear change history).

You can look at the change history in a window that is toggled with the F8 key.
In this window you can also directly jump to points in the history with a click.


\subsubsection{Set layer: \texttt{l}}\label{befehl-l}

As an alternative to the select field, you can set the layer used for the subsequently created elements with the command \texttt{l}.
For the layers you use the shortcuts defined in the layer configuration (cf. \ref{ebenenkonfiguration}).

\paragraph*{Command \texttt{l} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
command_l   =   "l " layer_shortcut
\end{lstlisting}
\end{framed}





\vskip4em
\center{\Large tbc.}
\kommentar{







\section{Abfragesprache}

\subsection{Suche}

Das Prinzip der Graphsuche von GraphAnno besteht darin, mit einer Menge von Klauseln ein Graphfragment zu beschreiben. Bei der Suche werden dann alle Teilgraphen des durchsuchten Korpusgraphen gefunden, die dieser Beschreibung entsprechen.
Es stehen die Klauseln \texttt{node}, \texttt{nodes}, \texttt{edge}, \texttt{link}, \texttt{text}, \texttt{meta}, \texttt{cond} und \texttt{def} zur Verfügung, wobei eine Anfrage mindestens eine \texttt{node}- oder \texttt{text}-Klausel oder eine unverbundene \texttt{edge}-Klausel enthalten muß. Die Klauseln werden in den folgenden Abschnitten im einzelnen beschrieben.

Die einzelnen Klauseln werden in beliebiger Reihenfolge in jeweils eine eigene Zeile geschrieben; Einrückungen und Leerzeilen werden nicht interpretiert. Kommentare werden durch Voranstellen eines Doppelkreuzes \texttt{\#} markiert.



\subsubsection{\texttt{node}}\label{node}

Die \texttt{node}-Klausel beschreibt einen Knoten, der im Graphfragment genau einmal vorkommen soll. Die Klausel besteht aus dem Schlüsselwort \texttt{node}, einer optionalen ID und einer Attributbeschreibung.

Die ID besteht aus einem \texttt{@} gefolgt von einer Zeichenkette, die aus einer Folge von alphanumerischen Zeichen inkl. Unterstrich besteht, wobei das erste Zeichen keine Ziffer sein darf. Unter der ID kann der Knoten in anderen Teilen der Suchanfrage referenziert werden.

Die Attributbeschreibung besteht aus Schlüssel-Wert-Paaren der Form \texttt{schlüssel:""wert}, die mit den logischen Operatoren \texttt{!} für „nicht“, \texttt{\&} für „und“ und \texttt{|} für „oder“ (Bindungsstärke: \texttt{!} > \texttt{\&} > \texttt{|}) sowie Klammerung mit runden Klammern verknüpft sind. Als Abkürzung für Disjunktionen von Schlüssel-Wert-Paaren mit dem gleichen Schlüssel steht die Form \texttt{schlüssel:wert1|wert2|...|wertn} zur Verfügung.

Der Schlüssel eines Schlüssel-Wert-Paares kann entweder als einfache Zeichenkette angegeben werden, wenn er keines der in der Abfragesprache verwendeten Steuerzeichen (\texttt{␣():!\&\quo/?+*\{\}@\#\^{}}) enthält, oder als Zeichenkette in doppelten Anführungsstrichen (\texttt{{\quo}xyz\quo}), die beliebige Zeichen enthalten darf (doppelte Anführungsstriche müssen mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}).

\phantomsection\label{zeichenketten}Die Werte der Schlüssel-Wert-Paare sind Zeichenketten, die auf dreierlei Art und Weise angegeben werden können. Die erste Variante sind einfache umarkierte Zeichenketten, die alle Zeichen außer den in der Abfragesprache verwendeten Steuerzeichen (\texttt{␣():!\&\quo/?+*\{\}@\#\^{}}) enthalten dürfen. Diese Zeichenketten werden bei der Suche ohne Beachtung von Groß- und Kleinschreibung verglichen.
Die zweite Variante sind Zeichenketten in doppelten Anführungsstrichen (\texttt{{\quo}xyz\quo}). Diese dürfen beliebige Zeichen enthalten (doppelte Anführungsstriche müssen mit einem Backslash maskiert werden: \texttt{\textbackslash\quo}) und werden unter Beachtung von Groß- und Kleinschreibung verglichen. 
Die dritte Variante sind reguläre Ausdrücke. Diese werden in Schrägstrichen angegeben (\texttt{/x.z/} und gehorchen den Regeln für reguläre Ausdrücke in Ruby (siehe \texttt{http://www.ruby-doc.org/""core/""Regexp.html}). Die regulären Ausdrücke sind nicht verankert; um den Ausdruck am Anfang bzw. Ende einer Zeichenkette zu verankern müssen also \texttt{\^} bzw. \texttt{\$} verwendet werden; eine beliebige Zeichenkette kann mit \texttt{//} gefunden werden.

Wie eine Attributbeschreibung kann das Schlüsselwort \texttt{token} verwendet werden, welches prüft, ob es sich beim Knoten um ein Token handelt.

Des weiteren kann die Attributbeschreibung Kriterien für ein- und ausgehende Kanten enthalten. Diese bestehen aus dem Schlüsselwort \texttt{in} bzw. \texttt{out}, einer optionalen Attributbeschreibung in runden Klammern und einem optionalen Quantor. Der Operator \texttt{in} bzw. \texttt{out} findet alle ein- bzw. ausgehenden Kanten mit den angegebenen Attributen, der Quantor gibt an, wieviele Kanten der spezifizierten Art vorhanden sein dürfen und ist (syntaktisch) wie bei regulären Ausdrücken definiert: \texttt{\{m,n\}} für mindestens m-mal, höchstens n-mal; bei Auslassung der ersten Zahl wird 0 angenommen, bei Auslassung der zweiten unendlich. \texttt{\{n\}} steht für genau n mal. Des weiteren gibt es die Abkürzungen \texttt{?} für \texttt{\{0,1\}}, \texttt{*} für \texttt{\{0,\}} und \texttt{+} für \texttt{\{1,\}}.
Anders als von regulären Ausdrücken gewohnt (und anders als beim Auftreten von Quantoren in anderen Kontexten der GraphAnno-Abfragesprache), wird das Fehlen eines Quantors hier als \texttt{\{1,\}} interpretiert.

Für die Kanten wiederum können – zusätzlich zu den einfachen Attributen – über die Schlüsselwörter \texttt{start} bzw. \texttt{end} und Attributbeschreibungen in runden Klammern auch Eigenschaften des Start- bzw. Zielknoten angegeben werden.

Ähnlich wie \texttt{in} und \texttt{out} funktioniert \texttt{link}, jedoch werden damit nicht nur ein- und ausgehenden Kanten abgefragt, sondern (ggf.) komplexere Verbindungen zu anderen Knoten. Wie diese Verbindungen spezifiziert werden, ist in \ref{link} beschrieben. Auch für \texttt{link} gelten die Regeln für Quantoren, wie für \texttt{in} und \texttt{out} beschrieben.

\paragraph*{Die \texttt{node}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
node-klausel    =   "node" id? " " knotenattribute
id              =   "@" (letter | "_") alnum*
knotenattribute =   knotenattribute " & " knotenattribute
                    knotenattribute " | " knotenattribute
                    "!" knotenattribute
                    "(" knotenattribute ")"
                    attribut
                    kantenkriterium
                    "token"
attribut        =   zeichenkette ":" attributwert ("|" attributwert)*
zeichenkette    =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """
attributwert    =   zeichen_außer_steuerzeichen+
                    """ beliebiges_zeichen* """
                    "/" regulärer_ausdruck "/"
kantenkriterium =   "in" ("(" kantenattribute ")")? quantor?
                    "out" ("(" kantenattribute ")")? quantor?
                    "link" ("(" verbindung ")") quantor?
quantor         =   "?" | "*" | "+" | "{" zahl? ("," zahl?) "}"
kantenattribute =   kantenattribute " & " kantenattribute
                    kantenattribute " | " kantenattribute
                    "!" kantenattribute
                    "(" kantenattribute ")"
                    attribut
                    knotenkriterium
knotenkriterium =   "start" ("(" knotenattribute ")")
                    "end" ("(" knotenattribute ")")
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Knoten, die die Kategorie S oder VP haben und keine Token sind:\\
	{\tt node cat:S|VP \& !token}
	\item Suche alle Knoten, die von der Kategorie VP sind oder Token mit dem pos-Wert verb:\\
	{\tt node cat:VP | token \& pos:verb}
	\item Suche alle Knoten der Kategorie S, die mindestens zwei ausgehende AUX-Kanten haben:\\
	{\tt node cat:S \& out(cat:AUX)\{2,\}}
	\item Suche alle Knoten der Kategorie S, die mindestens einen Knoten mit dem pos-Wert pro dominieren:\\
	{\tt node cat:S \& out(end(pos:pro))}
\end{itemize}



\subsubsection{\texttt{nodes}}

Die \texttt{nodes}-Klausel beschreibt eine Menge von Knoten, die im Graphfragment enthalten sein sollen – wenn die Menge nur als Ziel einer \texttt{link}- oder \texttt{edge}-Klausel auftritt, kann die Menge jedoch auch leer sein. Die \texttt{nodes}-Klausel hat, abgesehen vom Schlüsselwort,  die gleiche Syntax wie die \texttt{node}-Klausel.

\paragraph*{Die \texttt{nodes}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
nodes-klausel    =   "nodes" id? " " knotenattribute
\end{lstlisting}
\end{framed}






\subsubsection{\texttt{edge}}\label{edge}

Die \texttt{edge}-Klausel hat zwei Anwendungen. Zum einen kann sie verwendet werden, um einzelne Kanten zu suchen. Dann besteht die Klausel aus dem Schlüsselwort \texttt{edge}, einer optionalen ID, unter die die Kante in der Ausgabe referenziert werden kann, und einer Attributbeschreibung für Kanten wie in \ref{node} beschrieben. Zum anderen dient die \texttt{edge}-Klausel dazu, anzugeben, daß zwischen zwei Knoten bzw. Knotenmengen des Graphfragments (mit \texttt{node} bzw. \texttt{nodes} spezifiziert) eine Kante mit den angegebenen Eigenschaften existieren soll. Dazu werden nach der (optionalen) ID der Kante die IDs von Start und Ziel der Kante angegeben.

Durch die optionale ID und die verschiedenen Verwendungsmöglichkeiten kann das Schlüsselwort \texttt{edge} von null bis drei IDs gefolgt sein. Die Interpretation dieser IDs ergibt sich aus ihrer Anzahl und der Reihenfolge. Eine ID: ID der Kante selber; zwei IDs: Start und Ziel der Kante; drei IDs: ID der Kante, Start und Ziel.


\paragraph*{Die \texttt{edge}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
edge-klausel    =   "edge" id? (id id)? " " kantenattribute
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Kanten die die syntaktische Funktion Subjekt anzeigen:\\
	{\tt edge synfunc:subj}
	\item Suche alle Knoten der Kategorie S, jeweils mit der Menge von Knoten der Kategorie NP, die über eine Kante der Kategorie S, A oder P verbunden sind:\\
	{\tt
	node @s  cat:S\\[-.4ex]
	nodes @np cat:NP\\[-.4ex]
	edge @s@np cat:S|A|P
	}
\end{itemize}







\subsubsection{\texttt{link}}\label{link}

Die \texttt{link}-Klausel beschreibt, wie zwei Knoten oder Knotenmengen des Teilgraphen verbunden sein sollen. Dabei kann als Verbindung eine Kette von Knoten und Kanten ähnlich einem regulären Ausdruck beschrieben werden.
Die \texttt{link}-Klausel besteht aus den Schlüsselwort \texttt{link}, der Angabe von Start- und Endknoten der Verbindung in der Form \texttt{@id1@id2} und der Beschreibung der Verbindung.

Die Verbindungsbeschreibung besteht aus einer Abfolge von \texttt{edge}- und \texttt{node}-""Elementen. Diese bestehen aus dem jeweiligen Schlüsselwort (\texttt{edge} bzw. \texttt{node}) und optional einer Angabe von Bedingungen, die das Element erfüllen muß, in runden Klammern. Dabei handelt es sich um eine Attributbeschreibung wie oben für \texttt{node} angegeben. Gefolgt werden kann die Elementbeschreibung von einer ID, unter der die gefundenen Elemente in der Ausgabe (nicht in der Suche!) referenziert werden können.

Für Alternativen steht der Operator \texttt{|} „oder“ zur Verfügung; bezüglich der Bindungsstärke steht er unter der Abfolge. Klammerung ist mit runden Klammern möglich. Des weiteren können Quantoren verwendet werden. Diese werden weder als gierig noch als genügsam interpretiert; alle  passenden Verbindungen werden gefunden und als separate Treffer gewertet.

Eine Verbindung besteht – der Natur eines Graphen entsprechend – stets aus einem Wechsel von Knoten und Kanten (beginnend und endend mit jeweils einer Kante). Bei der Angabe von einer Verbindung darf jedoch darauf verzichtet werden, stets Knoten und Kanten im Wechsel anzugeben; nur die erste Kante darf nicht ausgelassen werden. Stehen zwei Elemente des gleichen Typs (also \texttt{edge} oder \texttt{node}) hintereinander, so wird bei der Suche dazwischen ein unspezifiziertes Element des jeweils anderen Typs eingeschoben. Die Verbindungsbeschreibung \texttt{edge(a:b) edge(c:d)} beispielsweise findet eine Kante mit dem Attribut \texttt{a:b}, dann einen beliebigen Knoten und dann eine Kante mit dem Attribut \texttt{c:d}.

Wird \texttt{link} als Knotenattribut (z.B. in einer \texttt{node}-Klausel) verwendet, fällt die Angabe von Start- und Endknoten weg. Startknoten ist dann der gesuchte Knoten, Endknoten der letzte in der Verbindung spezifiziert Knoten bzw., wenn die Verbindungsbeschreibung mit einer Kante endet, ein Knoten mit beliebigen Eigenschaften.


\paragraph*{Die \texttt{link}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
link-klausel    =   "link" id id " " verbindung
verbindung      =   verbindung " " verbindung
                    verbindung "|" verbindung
                    "(" verbindung ")"
                    verbindung quantor
                    "edge" ("(" kantenattribute ")")? id?
                    "node" ("(" knotenattribute ")")? id?
\end{lstlisting}
\end{framed}


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche alle Graphfragmente, die aus einem Knoten der Kategorie P und einem der Kategorie S bestehen, wobei ersterer letzteren über eine Kante der Kategorie EX dominiert:\\
	{\tt
	node @p cat:P\\[-.4ex]
	node @s cat:S\\[-.4ex]
	link @p@s edge(cat:EX)
	}
	\item Suche einen Knoten der Kategorie S, alle Knoten der Kategorie NP, die dieser dominiert, und alle Token, die von den NPn dominiert werden:\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @vpn cat:NP\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@npn edge+\\[-.4ex]
	link @npn@tok edge+
	}
	\item Suche einen Knoten der Kategorie S und alle Token, die von diesem über einen NP-Knoten dominiert werden (bis auf die IDs äquivalent zum vorigen Beispiel):\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@tok edge+ node(cat:NP) edge+
	}
\end{itemize}




\subsubsection{\texttt{text}}

Die \texttt{text}-Klausel dient dazu, eine Abfolge von Token-Knoten zu finden. Dabei ermöglicht die Textsuche sowohl die Suche nach reinem Text als auch nach weiteren Attributen der Token-Knoten.
Die \texttt{text}-Klausel besteht aus dem Schlüsselwort \texttt{text}, einer optionalen ID und der Beschreibung eines Textfragments, das mit \texttt{\^{}s} am Anfang bzw. Ende des Textes eines Satzes verankert werden kann.

Die Beschreibung des Textfragments besteht aus einer Abfolge von Wortbeschreibungen, die aus einer Zeichenkette, die den Tokentext beschreibt (drei Varianten wie oben unter \texttt{node} für die Werte in Schlüssel-Wert-Paaren beschrieben), und einer optionalen Angabe von Attributen (Attributebeschreibung wie oben unter \texttt{node}) in runden Klammern zusammengesetzt ist.
Für die Beschreibung des Textfragments stehen wie bei der Verbindungsbeschreibung der Operator \texttt{|} für „oder“ (Bindungsstärke schwächer als die der Sequenz), Klammerung und Quantoren zur Verfügung, wobei die Quantoren bei der Textsuche genügsam sind. Zusätzlich kann Textfragmenten eine ID nachgestellt werden, um die gefundenen Knoten in anderen Klauseln zu referenzieren. Quantoren und IDs haben eine höhere Bindungsstärke als Sequenz und Disjunktion; die Reihenfolge von Quantor und ID hinter dem selben Textfragment ist beliebig. Die optionale ID nach dem Schlüsselwort gilt für alle Knoten der \texttt{text}-Klausel. Das gesuchte Textfragment kann mit \texttt{\^{}s} am Beginn bzw. Ende eines Textes (Text eines Satzes) verankert werden.

\paragraph*{Die \texttt{text}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
text-klausel    =   "text" id? " " "^s"? textfragment "^s"?
textfragment    =   textfragment " " textfragment
                    textfragment "|" textfragment
                    "(" textfragment ")"
                    textfragment quantor
                    textfragment id
                    wort
wort            =   attributwert ("(" knotenattribute ")")?
\end{lstlisting}
\end{framed}

\paragraph*{Beispiel:}
\begin{itemize}
	\item Suche alle Sätze, in denen das Wort das Nomen „Säge“ an dritter Stelle steht:\\
	{\tt
	text \^{}s //\{2,2\} Säge(pos:n)
	}
	\item Suche zwei Vorkommen von „er“, die von einer beliebigen Anzahl Wörter getrennt sind, wobei das erste „er“ und alle folgenden Wörter bis zum zweiten „er“ von einem Knoten vom cat S dominiert werden:\\
	{\tt
	node @s cat:S\\
	text (er //*)@t er\\
	link @s@t edge*
	}
\end{itemize}



\subsubsection{\texttt{meta}}

Die \texttt{meta}-Klausel schränkt die Menge der zu durchsuchenden Sätze ein. Über diese Klausel können Eigenschaften angegeben werden, die der Satznoten eines Satzes haben muß. Die Klausel besteht aus dem Schlüsselwort \texttt{meta} und einer Attributbeschreibung wie oben unter \texttt{node} beschrieben.

\paragraph*{Die \texttt{meta}-Klausel in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
text-klausel    =   "meta " attribute
\end{lstlisting}
\end{framed}



\subsubsection{\texttt{cond}}\label{cond}

Die \texttt{cond}-Klausel gibt Bedingung an, die das Graphfragment erfüllen muß und wirkt wie ein Filter. Die Klausel besteht aus dem Schlüsselwort \texttt{cond} und der Bedingung in Ruby-Kode. Die Knoten und Knotenmengen werden dabei durch die vergebenen IDs referenziert. Bei der Referenzierung ist zu beachten, daß es sich bei den mit \texttt{node} und \texttt{edge} gefundenen Knoten und Kanten um einzelne Elemente, bei den mit \texttt{nodes}, \texttt{text} und \texttt{link} gefundenen Knoten und Kanten hingegen um Arrays von Elementen handelt.

Auf die Attribute der Knoten wird in der Form \texttt{['schlüssel']} zugegriffen; für die Attribute \texttt{token} und \texttt{cat} stehen Abkürzungen der Form \texttt{.token} und \texttt{.cat} zur Verfügung. Über die Methode \texttt{.sentence} kann auf den Satznoten des Satzes, zu dem das Element gehört, zugegriffen werden. Bei der Verwendung von Attributwerten ist zu beachten, daß es sich bei diesen stets um Zeichenketten handelt; sollen sie als Zahlen behandelt werden, müssen sie mit \texttt{.to\_i} bzw. \texttt{.to\_f} umgewandelt werden.


\paragraph*{Beispiele:}
\begin{itemize}
	\item Suche zwei S-Knoten, die über eine ad-Kante verbunden sind und den gleichen Wert für tns haben:\\
	{\tt
	node @s1 cat:S\\[-.4ex]
	node @s2 cat:S\\[-.4ex]
	link @s1@s2 cat:ad\\[-.4ex]
	cond @s1['tns'] == @s2['tns']
	}
	\item Suche alle S-Knoten, die mindestens drei Token dominieren:\\
	{\tt
	node @s cat:S\\[-.4ex]
	nodes @tok token\\[-.4ex]
	link @s@tok edge+\\[-.4ex]
	cond @tok.length >= 3
	}
\end{itemize}


\subsubsection{\texttt{def}}\label{def}

Mit \texttt{def} besteht die Möglichkeit, für die Suche Makros zu definieren. Dabei wird ein Name angegeben, unter dem das Makro in den Suchklauseln angesprochen werden kann, und eine Attribut- oder Verbindungsbeschreibung, die durch den Namen vertreten wird. Die Attribut-/Verbindungsbeschreibung ist aufgebaut wie für \texttt{node} und \texttt{link} in \ref{node} bzw. \ref{link} beschrieben.

Es ist zu beachten, daß ein Makro quasi automatisch geklammert wird, also stets zuerst ausgewertet wird. Nehmen wir beispielsweise an, man definiert ein Makro als \texttt{cat:S | cat:VP} wie unten im Beispiel und kombiniert es durch den Operator \texttt{\&} mit einer weiteren Bedingung – \texttt{tns:prs} wie beim zweiten Knoten im Beispiel. Dann wird dies nicht als \texttt{cat:S | cat:VP \& tns:prs} ausgewertet, in welchem Falle das \texttt{\&} Präzedenz über das \texttt{|} nähme, sondern als \texttt{(cat:S | cat:VP) \& tns:prs}.

\paragraph*{Die Makrodefinition \texttt{def} in modified BNF:}
~
\begin{framed}
\begin{lstlisting}
makrodefinition =   "def " name " " makro
makro           =   kantenattribute
                    knotenattribute
                    verbindung
name            =   alnum+
\end{lstlisting}
%\begin{lstlisting}
%makrodefinition =   "def " name " " (kantenattribute | knotenattribute)
%name            =   alnum+
%\end{lstlisting}
\end{framed}


\paragraph*{Beispiel:}
\begin{itemize}
	\item Suche zwei Knoten mit \texttt{cat:S} oder \texttt{cat:VP}, die über eine Kante verbunden sind, und von denen der zweite im Präsens steht:\\
	{\tt
	def svp cat:S | cat:VP\\[-.4ex]
	node @s1 svp\\[-.4ex]
	node @s2 svp \& tns:prs\\[-.4ex]
	edge @s1@s2\\[-.4ex]
	}
%\begin{itemize}
%	\item Suche zwei Knoten mit \texttt{lemma:cum} und \texttt{pos:G-}, die über eine Kante verbunden sind, und von denen einer ein Token ist:\\
%	{\tt
%	def cum lemma:cum \& pos:G-\\[-.4ex]
%	node @s1 cum\\[-.4ex]
%	node @s2 cum \& token\\[-.4ex]
%	edge @s1@s2\\[-.4ex]
%	}
\end{itemize}



\subsection{Annotation}

Nach dem Durchführen einer Suche können unter Zuhilfenahme der in der Suche vergebenen IDs automatisch Annotationen durchgeführt werden. Dazu stehen die in Abschnitt \ref{annotationsbefehle} vorgestellten Annotationsbefehle (außer \texttt{t}) zur Verfügung.

Aufgrund des anderen Verwendungskontextes sind ein paar Änderungen zu beachten:
\begin{itemize}
	\item Anstelle der Knoten- und Kantenreferenzen der Form \texttt{n7}, \texttt{t8} oder \texttt{e13} werden die in der Suche definierten IDs (in der Form \texttt{@s1} o.ä.) verwendet. 
	\item Es ist keine Ebene voreingestellt. Es sollte also ggf. bereits im ersten Annotationsbefehl der Befehlsfolge ein Ebenenschalter eingesetzt werden.
	\item Beim Befehl \texttt{n} ist ein Knoten anzugeben, der den Satz festlegt, in dem der neue Knoten erstellt werden soll.
	\item Da die IDs sowohl für einzelne Elemente als auch für Mengen von Elementen stehen können, ergeben sich ein paar Besonderheiten: Beim Befehl \texttt{e} sind genau zwei IDs anzugeben; handelt es sich um einzel-IDs, so wird eine einzelne Kante erstellt, handelt es sich jedoch um eine einzel- und eine Mengen-ID oder zwei Mengen-IDs, so wird für jede Knotenkombination aus den beiden IDs eine Kante gezogen. Bei den Tokenisierungsbefehlen \texttt{tb}/\texttt{ta} wird das erste bzw. letzte Token gewählt, falls mehrere angegeben wurden. Bei allen anderen Befehlen können beliebig viele Mengen- und/oder einzel-IDs angegeben werden, die dann als \textit{eine} Menge von Elemente behandelt werden.
	\item Bei der Angabe von Attributen kann für den Wert auf die in der Suche gefundenen Elemente zurückgegriffen werden. Dazu wird die Zeichenkette für den Wert in doppelten Anführungszeichen angegeben und darin kann, wie in Ruby gebräuchlich, in geschweiften Klammern mit vorangestelltem Rautenzeichen Ruby-Kode verwendet werden, in dem die gefundenen Elemente mit ihren IDs referenziert werden. Eine Such-/Annotationskombination, die alle Satzknoten mit dem von ihnen dominierten Text versieht (mit Punkt abgeschlossen) könnte z.B. folgendermaßen aussehen:
	\begin{verbatim}
		node @s cat:S
		a @s text:"#{@s.text}."
	\end{verbatim}
\end{itemize}



\subsection{Datenexport}

Die GraphAnno-Abfragesprache biete auch Funktionalität zum Exportieren von Suchergebnissen als CSV-Dateien an. 
Mit den nachfolgen beschriebenen Klauseln kann angegeben werden, wie Infomationen der in einer zuvor durchgeführten Suche gefundenen Teilgraphen ausgegeben werden sollen.
Die Daten jedes gefundenen Teilgraphen werden in eine Zeile der CSV-Datei geschrieben, mit \texttt{sort} können die Ergebnisse sortiert werden, mit \texttt{col} wird angegeben, welche Spalten mit welchen Werten angelegt werden sollen. Als erste Spalte wird stets eine fortlaufende Numerierung der Ergebnisse mit ausgegeben.

\subsubsection{\texttt{sort}}

Die \texttt{sort}-Klausel dient dazu, die Ausgabe der gefundenen Teilgraphen zu sortieren. Es können mehrere \texttt{sort}-Klauseln angegeben werden, wobei weiter unten angegeben Klauseln nur ausgewertet werden, wenn  weiter oben angegebenen Klauseln keine Reihenfolge zwischen zwei Teilgraphen ergeben. 
Eine \texttt{sort}-Klausel wird in Ruby-Kode formuliert und muß einen Wert ergeben, der für die Sortierung verglichen werden soll. Wie bei \texttt{cond} werden die gefundenen Knoten und Kanten über die in der Suche vergebenen IDs referenziert. Bei Verwendung von Attributwerten ist zu beachten, daß es sich bei diesen stets um Zeichenketten handelt; sollen sie als Zahlen verglichen werden, müssen sie mit \texttt{.to\_i} bzw. \texttt{.to\_f} umgewandelt werden.

\paragraph*{Beispiele:}
\begin{itemize}
	\item Sortiere die Ergebnisse nach Satznamen, bzw. nach Tokennummer (die Methode \texttt{.tokenid} gibt die Stelle des Tokens im Satz, beginnend mit 0, aus), wenn sie dem gleichen Satz angehören (durch die Suchanfrage sei gegeben: ein Token mit der ID \texttt{@t1}):\\
	{\tt
	sort @t1.sentence.name\\[-.4ex]
	sort @t1.tokenid\\[-.4ex]
	}
\end{itemize}



\subsubsection{\texttt{col}}

Jede \texttt{col}-Klausel steht für eine zu exportierende Spalte. Sie hat als ersten Parameter den Spaltentitel (der keine Leerzeichen enthalten darf), gefolgt von Ruby-Kode, der den auszugebenden Wert ergibt. Knoten und Kanten werden wie gehabt über ihre in der Suche vergebene ID referenziert, dabei ist zu beachten, daß es sich bei den mit \texttt{node} gefundenen Knoten um einzelne Knoten, bei den mit \texttt{nodes}, \texttt{text} und \texttt{link} gefundenen Knoten hingegen um Arrays von Knoten handelt.

Zugriff auf Attribute erfolgt wie unter \ref{cond} für \texttt{cond} beschrieben. Es gibt jedoch noch weitere für die Ausgabe nützliche Methoden: \texttt{.tokens} gibt die über syntaktische Kanten dominierten Token als Liste aus, \texttt{.text} deren Text als Zeichenkette (die einzelnen Tokentexte mit Leerzeichen getrennt). \texttt{.sentence\_tokens} gibt alle Token des Satzes, dem das Element angehört als Liste aus, \texttt{.sentence\_text} wiederum deren Text. \texttt{.position} gibt die Position eines Knotens als Durchschnitt der Positionen seiner dominierten Token aus.



}


\end{document}