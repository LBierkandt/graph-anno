\documentclass[12pt]{scrartcl}
\usepackage{fontspec}
\usepackage[ngerman,english]{babel}
\useshorthands{"}
\addto\extrasenglish{\languageshorthands{ngerman}}\usepackage{linguex}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{url}
\usepackage{xcolor}
\usepackage{soul}
\usepackage[pdfpagemode=UseNone, colorlinks=true, allcolors=darkblue]{hyperref}
\usepackage{tikz}

%\KOMAoptions{BCOR=16mm}
\KOMAoptions{DIV=10}


\setmainfont[WordSpace={1,1.15,1},Numbers=Proportional]{Linux Libertine O}
\setsansfont[Scale=MatchLowercase]{Linux Biolinum O}
\setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}

\textheight22.4cm % 42 Zeilen {\baselinestretch}{1.05}
% \voffset-4mm
% %\headsep4mm


%\parindent0pt
%\parsep0ex
\setkomafont{sectioning}{\rmfamily}%\bfseries}
%\setcounter{secnumdepth}{1}
%\setcounter{tocdepth}{2}
%\qtreecenterfalse
\frenchspacing

\let\origitemize\itemize
\def\itemize{\origitemize\itemsep-0.5ex}
\let\origenumerate\enumerate
\def\enumerate{\origenumerate\itemsep-0.5ex}
%\let\origdescr\description
%\def\description{\origdescr\itemsep-0.5ex}
\renewcommand{\labelitemi}{–}
\renewcommand{\labelitemii}{-}
\newcommand{\anf}[1]{‚#1‘}
\newcommand{\ti}{\char"223C}
\newcommand{\quo}{\char"0022}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
%\renewcommand{\bottomfraction}{1}

\definecolor{darkblue}{rgb}{0,0,.5}
\definecolor{lightgray}{rgb}{.92,.92,.92}
\sethlcolor{lightgray}

\newcommand{\code}[1]{\hl{\texttt{#1}}}
\lstset{
	basicstyle=\renewcommand{\baselinestretch}{1}\tt,
	tabsize=4,
	backgroundcolor=\color{lightgray},
	aboveskip=.8em,
	belowskip=.8em,
	xleftmargin=.7em,
	frame=tblr,
	framesep=.3em,
	framexleftmargin=.4em,
	framerule=0pt
}

\title{\LARGE GraphAnno\\ \large An annotation and query tool\\for graph-based linguistic annotations}
\author{Lennart Bierkandt\\\large Friedrich-Schiller-Universität Jena\\[-.2em]\large post@lennartbierkandt.de}
\date{Version of \today}


\renewcommand{\glt}{\vspace{-\Extopsep}}
\renewcommand{\firstrefdash}{}
\newcommand{\re}{\vspace{-.33\Extopsep}} %{-1.33\Extopsep} für normalen Zeilenabstand bei \ex. mit \gll, 0.66 ohne \gll
\newcommand{\regll}{\vspace{-\Extopsep}\gll}
\let\eachwordtwo=\glosse
\glossglue = 5pt plus 2pt minus 2pt


\newenvironment{figurel}{\begin{figure}[htb]}{\end{figure}}
\newenvironment{tablel}{\begin{table}[htb]}{\end{table}}

\newenvironment{anmerkung}{\par{\ }\par\sf\color{black!60}\noindent\textbf{Remark:}\par}{\newline\par}

\newcommand{\kommentar}[1]{}

\setlength{\abovecaptionskip}{0ex}








\begin{document}

\maketitle

\renewcommand{\baselinestretch}{1.05}\normalsize

\tableofcontents



\section{Introduction}

GraphAnno started off as an elementary internal tool of the Linktype project\footnote{\textit{Towards a corpus-based typology of clause linkage} (\url{http://linktype.iaa.uni-jena.de}), funded by the \textit{Deutsche Forschungsgemeinschaft} (\url{http://dfg.de})}, but over time, it grew, got more and more features and became more user-friendly.

It was developed out of the need for an annotation tool that allows for structural annotations not restricted to a specific framework, linguistic theory or tagset.
First of all, we needed the possibility to build unrestricted graph structures – not only trees – and to have multiple and arbitrarily overlapping layers.

As interface for the tool’s main task, the manual annotation, we chose the command line, which enables a fast annotation flow once you have become acquainted with the commands (an effort that quickly pays off).

When it comes to working with the data, GraphAnno offers a powerful query language for finding graph fragments and exporting data to CSV files.
The latter still requires a small amount of programming skills but relieves you of writing export scripts from scratch.\\

We hope that you will find GraphAnno as useful as we do and enjoy working with it.



\section{Requirements and installation}

GraphAnno is a Ruby program and thus needs an installation of Ruby (version 2.0 or higher; you may install it with your package manager or from \url{http://www.ruby-lang.org/}); you don’t need Ruby on Windows as there is a precompiled version of GraphAnno for Windows. For GraphAnno’s user interface you need a decent browser (GraphAnno has been developed with Firefox, but Chrome should work, too).\\

\noindent
Installation:
\begin{enumerate}
	\item Download the ZIP file \url{https://github.com/LBierkandt/graph-anno/archive/master.zip} and extract it to a directory of your choice (or clone the GraphAnno repository if you like to use Git).
	\item Install the needed libraries (Rubygems):
		\begin{enumerate}
			\item navigate to the GraphAnno main directory,
			\item run \code{gem install bundler} if you haven't installed bundler already,
			\item run \code{bundle install}
		\end{enumerate}
\end{enumerate}

\noindent
Starting GraphAnno:
\begin{enumerate}
	\item start \code{main.rb} in the GraphAnno main directory by running \code{bundle exec ruby main.rb}; on Windows without Ruby, run \code{main.exe},
	\item navigate to this address in your browser: \code{http://localhost:4567/}
\end{enumerate}

\noindent
To stop the program, press ctrl + C in the console where it is running.



\section{GraphAnno’s data model}

All data in GraphAnno is represented as a graph, i.e., a set of nodes and a set of directed edges that connect the nodes.
Nodes and edges bear attributes in the form of key-value pairs, that serve mainly the linguistic annotation.
Furthermore, there are multiple types of nodes and edges that fulfil different functions.

The structure of the GraphAnno data model is explained in Section \ref{graph-model}, Section \ref{serialization-format} describes the details of the serialization format that is used to store GraphAnno data.
The former section is probably helpful for every user in order to grasp the concept of GraphAnno data representation and get to know some terminology, whereas the latter one is intended for users who want to work with the serialized data, e.g., create or process GraphAnno data with their own scripts.


\subsection{Graph model}\label{graph-model}

As already said, GraphAnno represents all data in a graph, consisting of differend types of nodes and edges.
The most important types – those that are also displayed as a graph to the user – are \textit{token nodes}, \textit{annotation nodes} and \textit{annotation edges}.
These elements are directly created by the user and represent the linguistic data and annotation.
They may be annoted with \textit{attributes} (see below).

The data in GraphAnno is partitioned into \textit{sentences} (without any theoretical implication, i.e., just user-defined chunks of language data), which may be, in turn, recursively grouped into sections.
Sentences are represented by \textit{sentence nodes}.
These are connected to their token nodes and annotation nodes via \textit{sentence edges}.
Sections are represented by \textit{section nodes} and connected to the sections or sentences they contain via \textit{section edges}.
As sentences and sections are subject to certain constraints – e.g., they must be arranged hierarchically –  they are created via special commands, that also take care of creating the required edges.
Sentence and section nodes may also be annotated with attributes.

Finally, we have to mention the \textit{order edges}, that are used program-internally for representing the linear order of sentence nodes and token nodes.
The structure of a full GraphAnno graph with all types of elements is shown by means of a mini example corpus in Figure \ref{fig-data-model}.

\begin{figurel}
	\centering
	\begin{tikzpicture}[xscale=2.2, yscale=1.2]
		% token nodes
		\begin{scope}[blue!80!black]
			\node (Amareh) at (0,0)     [draw] {\small Amareh};
			\node (wurde)  at (1,0)     [draw] {\small became};
			\node (sein)   at (2,0)     [draw] {\small his};
			\node (Weib)   at (3,0)     [draw] {\small wife};
			\node (dann)   at (4,0)     [draw] {\small then};
			\node (er)     at (5,0)     [draw] {\small he};
			\node (starb)  at (6,0)     [draw] {\small died};
		\end{scope}
		% anno nodes and edges
		\begin{scope}[green!80!black]
			\node (NP)     at (2.5,1)   [draw] {\small NP};
			\node (S1)     at (1.25,2)  [draw] {\small S};
			\node (S2)     at (5,1)     [draw] {\small S};
			\draw (NP)[->]--(sein);
			\draw (NP)[->]--(Weib);
			\draw (S1)[->]--(Amareh);
			\draw (S1)[->]--(wurde);
			\draw (S1)[->]--(NP);
			\draw (S2)[->]--(dann);
			\draw (S2)[->]--(er);
			\draw (S2)[->]--(starb);
			\draw (sein)[->]..controls++(1,.6)and++(-1,.8)..(er);
		\end{scope}
		% sentence nodes and edges
		\begin{scope}[blue!60!red]
			\node (Satz1)  at (1.5,-1.5)[draw] {\small sentence1};
			\node (Satz2)  at (5,-1.5)  [draw] {\small sentence2};
			\draw (Satz1)[->]--(Amareh);
			\draw (Satz1)[->]--(wurde);
			\draw (Satz1)[->]--(sein);
			\draw (Satz1)[->]--(Weib);
			\draw (Satz1)[->]..controls++(0,2)and++(.2,-1)..(S1);
			\draw (Satz1)[->]..controls++(.7,1.2)and++(0,-1.2)..(NP);
			\draw (Satz2)[->]--(dann);
			\draw (Satz2)[->]--(er);
			\draw (Satz2)[->]--(starb);
			\draw (Satz2)[->]..controls++(.4,1.2)and++(.5,-1)..(S2);
		\end{scope}
		% section nodes and edges
		\begin{scope}[red!70!black]
			\node (Absatz) at (3.25,-3) [draw] {\small section1};
			\draw (Absatz)[->]--(Satz1);
			\draw (Absatz)[->]--(Satz2);
		\end{scope}
		% OrderEdges
		\begin{scope}[yellow!50!black]
			\draw (Amareh)[->]--(wurde);
			\draw (wurde)[->]--(sein);
			\draw (sein)[->]--(Weib);
			\draw (dann)[->]--(er);
			\draw (er)[->]--(starb);
			\draw (Satz1)[->]--(Satz2);
		\end{scope}
	\end{tikzpicture}\vspace{2ex}
	\begin{tikzpicture}[xscale=.45, yscale=.5]
		% Legende
		\draw[green!80!black] (0,0)--++(1,0) node[right,align=left]{\small annotation nodes\\[-.5ex]\small and edges};
		\draw[blue!80!black]  (9,0)--++(1,0) node[right,align=left]{\small token\\[-.5ex]\small nodes};
		\draw[blue!60!red]    (14,0)--++(1,0) node[right,align=left]{\small sentence nodes\\[-.5ex]\small and edges};
		\draw[red!70!black]   (22,0)--++(1,0) node[right,align=left]{\small section nodes\\[-.5ex]\small and edges};
		\draw[yellow!50!black](29,0)--++(1,0) node[right,align=left]{\small order\\[-.5ex]\small edges};
	\end{tikzpicture}
	\caption{The GraphAnno data model – an example}
	\label{fig-data-model}
\end{figurel}

As mentioned above, token nodes, annotation nodes and edges as well as sentence and section nodes may be annotated with \textit{attributes} (I will also call them \textit{annotations}).
Attributes are key-value pairs, i.e., each element may bear a set of keys each of which has an associated value.
The keys forming a set implies that each key may only appear once on an element.
Both keys and values are always strings.
There are some privileged keys that bear a special meaning in GraphAnno:
The text of token nodes is stored as value of the key \code{token}; the key \code{cat} on annotation nodes and edges is privileged insofar as its value is displayed on top of the element’s annotations without the key; on sentence and section nodes the value of the key \code{name} is used as label for the elements in the navigation window and for referencing.

GraphAnno also provides the possibility to assign annotation nodes and edges to different layers (token nodes cannot belong to layers).
Each node or edge may belong to one or more layers, which is represented by the element carrying a list of layers to which it belongs.
This representation allows for layers to overlap in an arbitrary manner.
Nodes and edges of different layers may be displayed in different colors and aligned in different ways (see \ref{ebenenkonfiguration} for how to configure the layers and their display).


\subsection{Serialization format}\label{serialization-format}

For persisting, the GraphAnno data is serialized as a JSON\footnote{See \url{http://json.org/} for a description.} object.
This object has three obligatory keys: \code{nodes} and \code{edges} with an array of nodes and an array of edges, respectively, and \code{version} with the format version number (integer).
This is shown in Figure \ref{json-basic}.
Furthermore, the JSON object has a number of optional attributes for configuration.

\begin{figurel}
	\begin{lstlisting}[gobble=8]
		{
		  "nodes": <array>,
		  "edges": <array>,
		  "version": <integer>
		}
	\end{lstlisting}
	\caption{A basic GraphAnno graph JSON object}
	\label{json-basic}
\end{figurel}

Each node has the attributes \code{id} with a unique identifier (integer) and \code{type} for representing the type of the node (string).
For the strings representing the different node and edge types see Table \ref{types-strings}.
Optionally, a node bears the attribute \code{attr} with its annotations (object), that are arbitrary keys with string values.
Annotation nodes also optionally bear the attribute \code{layers} (array), a list of strings that are taken from the layer shortcuts as defined in the \code{conf} attribute of the graph.

Edges have the same attributes as nodes plus the additional attributes \code{start} and \code{end} with the IDs of the edges’s start and end node, respectively.
Only annotation edges, however, may bear \code{attr} and \code{layers}.

The structure of nodes and edges in JSON format can be seen in Figure \ref{json-node} and \ref{json-edge}, respectively.

\begin{tablel}
	\begin{center}
		\begin{tabular*}{12em}{@{\extracolsep{\fill}} ll}
			\toprule
			Type & String\\
			\midrule
			token node & \code{t}\\
			annotation node & \code{a}\\
			sentence node & \code{s}\\
			section node & \code{p}\\
			\midrule
			annotation edge & \code{a}\\
			sentence edge & \code{s}\\
			section edge & \code{p}\\
			order edge & \code{o}\\
			\bottomrule
		\end{tabular*}
	\end{center}
	\caption{Node and edge type strings used in JSON format}
	\label{types-strings}
\end{tablel}

\begin{figurel}
	\begin{lstlisting}[gobble=8]
		{
		  "id": <integer>,
		  "type": "t" | "a" | "s" | "p",
		  "attr": <object>,
		  "layers": <array>
		}
	\end{lstlisting}
	\caption{A GraphAnno node JSON object}
	\label{json-node}
\end{figurel}
\begin{figurel}
	\begin{lstlisting}[gobble=8]
		{
		  "id":<integer>,
		  "start":<integer>,
		  "end":<integer>,
		  "type": "a" | "s" | "p" | "o",
		  "attr":<object>,
		  "layers": <array>
		}
	\end{lstlisting}
	\caption{A GraphAnno edge JSON object}
	\label{json-edge}
\end{figurel}

This structure could describe arbitrary directed graphs, but in order to work with GraphAnno, the graph has to meet a number well-formedness conditions. These include the permitted start and end node types for the different edge types listed in Table \ref{edge-types} and the following conditions:

\begin{itemize}
	\item All sentence nodes must be linearily ordered via order edges.
	\item Every token node must be directly dominated by exactly one sentence node via a sentence edge.
	\item The token nodes of a sentence must be linearily ordered via order edges.
	\item A sentence node or section node may be dominated by at most one section node.
	\item The sentence nodes directly dominated by a section node must be contiguous.
	\item The section nodes directly dominated by another section node must be contiguous in the sense that no other section node intervene in terms of the order defined by the dominated sentence nodes.
\end{itemize}

\begin{table}[tb]
	\begin{center}
		\begin{minipage}{20em}
			\begin{tabular*}{20em}{@{\extracolsep{\fill}} lll }
				\toprule
				Edge type & start/end & permitted node types\\
				\midrule
				annotation & start & annotation, token\\
				& end & annotation, token\\
				sentence & start & sentence\\
				& end & token, annotation\\
				section & start & section\\
				& end & section, sentence\\
				order\footnote{An order edge may only connect nodes of the same type.} & start & token, sentence\\
				& end & token, sentence\\
				\bottomrule
			\end{tabular*}
		\end{minipage}
	\end{center}
	\caption{Permitted node types for start and end nodes of different edge types}
	\label{edge-types}
\end{table}


\subsubsection{Multi-file corpora}

For working with larger corpora, it can be handy to load only parts of a corpus.
To this end you may create multi-file corpora, that can be loaded partially (currently it is not yet possible to create such multi-file corpora from within GraphAnno).
A multi-file corpus consists of a master file and several part files, where the master file contains the configuration of the corpus and, optionally, independent nodes or edges, and the part files contain (consecutive) sentence nodes with their dominating section nodes and their associated token and annotation node, plus all connecting edges.

The master file contains the version attribute, all configuration attributes and, additionally, the attributes \code{files}, \code{max\_node\_id} and \code{max\_edge\_id}.
The value for \code{files} is an array of the relative paths of the part files (in the order their content has in the corpus).
The value for \code{max\_node\_id} and \code{max\_edge\_id} is the highest node ID or edge ID, respectively, of the whole corpus graph.
In some cases the master file may contain nodes, but no sentence or section nodes (i.e. a section cannot cross the boundaries of part files); only speaker nodes and sentence-independent nodes (to be implemented) are allowed.
The master file contains those edges that connect nodes of the master file itself; nodes that connect nodes of the master file and nodes of a part file belong to the part file.

A part file contains the version attribute, the attribute \code{master}, and nodes and edges.
The value of \code{master} is the relative path of the master file.
The nodes are a consecutive number of sentence nodes, with their dominating section nodes as well as their associated tokens and annotation nodes.
The edges comprise all edges that connect the nodes of the part file, plus those edges that connect nodes of the part file and nodes of the master file.
It is not possible to have edges between nodes of different part files.

See Section \ref{data-and-navigation} for how to handle loading and saving of multi-file corpora.



\section{User interface}

The main elements of GraphAnno’s user interface are the area where the annotation graph is displayed and, below, the command line, that is used for most operations (esp. for annotation; see Section \ref{commandline}).
Further elements on the bottom of the screen are a dropdown for annotation layer choice and the display of, i.a., the loaded file.
For some operations like, e.g., searching your annotations there are dedicated windows; these are discussed in detail in Section \ref{windows}.
Finally, you can use keyboard shortcuts for some operations like, e.g., toggling windows, navigating or zooming.
These shortcuts are listed in Section \ref{shortcuts}.


\subsection{Command line}\label{commandline}

The annotation work in GraphAnno (as well as workspace-related operations like loading and saving files) is operated from the command line.
Most commands are executed immediately; some (like, e.g., the \hyperref[konfiguration]{configuration commands}) open a dialogue window.
For issuing a command, you just type it, followed by its arguments, into the command line field and press the enter key.
For a complete list of the available commands see Section \ref{commandline-commands}.

There is also an autocomplete feature for the command line, that may speed up typing your commands.
This feature can be activated and customized in the preferences (see \ref{preferences}).
It suggests commands and, depending on the current command, file names, sentence names, annotations, makros etc.
A list of suggestions appears as soon as you have typed the first letter; then you choose the desired item with the up/down keys and select it with the tab key (attention: the enter key does not work for this, but submits the command line); you can close the suggestion list with the esc key.


\subsection{Windows}\label{windows}

For some purposes GraphAnno has dedicated static windows.
These windows can be toggled, dragged around and resized.
Their position, size and display status (shown or hidden) is saved in the browser (in a cookie) or, optionally, in the corpus file (see \ref{filesettings}) so you have the windows positioned as needed when you open your corpus.
The different windows are described in the following.

\subsubsection{Navigation}\label{window-navigation}

The navigation window shows the sentences and sections of your corpus and is toggled with the F9 key.
The sentences are listed from top to bottom and labelled with their \code{name} attribute and their text.
To the left of the sentences you can see the sections (again, labelled with their \code{name} attribute) as boxes whose height indicates which sentences/sections they span.
The active sentence(s) or section(s) are highlighted.

In order to navigate to a sentence or section, you can doubleclick the corresponding element.
For choosing multiple sentences or sections, you can use the ctrl and shift keys and select the elements with single clicks.
With the enter key you confirm your selection (or cancel with esc).
You may also use the up/down arrow keys for navigating (and selecting) inside the navigation window.
Note that you may only choose elements of the same level (i.e., the same column in the window).

Instead of clicking into the navigation window, you can jump into it using alt + the up/down arrow keys (the window will be shown if it has been hidden before).
The currently chosen sentences/sections will be selected and you may proceed as described in the previous paragraph.

For a quicker navigation from sentence to sentence (without explicitly using the navigation window), you may want to use the keyboard shortcuts alt + [left, right, pos1, end] as listed in \ref{shortcuts}; moreover, you can use the command \code{s} from the command line (see \ref{befehl-s}).

\subsubsection{Filter}

GraphAnno’s filter function allows you to hide or filter a set of nodes and edges of the current sentence in order to obtain a better overview of what is relevant to your current annotation task.
You may, e.g., decide to display only those elements that belong to a certain annotation layer.

In the filter window, toggled with the F6 key, you choose a set of elements via an attribute description of GraphAnno’s query language as described in Section \ref{node}.
By clicking one of the respective buttons, you may then choose to either hide/filter the described set or hide/filter the rest.
\textit{Hide} here means that hidden elements are displayed in a non-prominent color (you may customize this color in the respective settings, see \ref{ebenenkonfiguration}); \textit{filter} means that the filtered elements are not displayed at all.
In order to show all elements in the usual way again, click the \textit{display all} button.

\subsubsection{Search}\label{window-search}

GraphAnno’s search feature is controlled from the corresponding window, that is toggled with the F7 key.
The search window has a single input area for search, annotation and export queries.
Query parts relating to all of these three functions can be mixed in the input area.
The queries are formulated in GraphAnno’s query language, which is explained in Section \ref{querylanguage}.
As soon as you have entered your query, you can start the desired action (search, annotation or export) by clicking the corresponding button.

When you want to search for a graph fragment, enter your search query in the input area and click the \textit{search} button.
The search will then be executed and, as soon as it is finished, the number of matches will be displayed on the bottom of the search window.
The matching fragments are highlighted in the graph view (default is red, but the color can be customized, see \ref{ebenenkonfiguration}), and in the navigation window all sentences and sections that contain matches are highlighted as well.
In order to jump to the next or previous sentence/section with a match, you may use the shortcuts alt + n or alt + p, respectively. 
If your query is not correct or if another error occurs during the search, an error message is displayed on the bottom of the search window.
If you don’t want the matches to be highlighted anymore, just click the \textit{clear search} button (this will also internally clear the search results, so you have to search again before annotation – see the next paragraph).

When you want to annotate using an annotation query, you enter a search query and an annotation query.
The search query finds a set of matches and saves the relevant elements of the match in variables (or \textit{IDs}).
In your annotation query you write commands that refer to these variables.
In order to perform the annotation, you must first execute the search and afterwards the annotation.
If you make changes in your search query and want them to take effect for your annotation, you must, again, first execute the modified search.

For exporting a data table, you proceed analogously to the annotation procedure described in the preceding paragraph:
Enter a search query and export commands that refer to the IDs from the search query; then execute the search first and the export afterwards.

\subsubsection{Log}\label{window-log}

GraphAnno records the change history of an annotation session (or of the whole corpus; you can configure this in the file settings, see \ref{filesettings}).
The commands recorded include those commands that create or delete nodes or edges, as well as creating and deleting of sentences and sections, but not work space-related commands such as \code{append} or \code{clear} and not annotation by query (cf. Section \ref{window-search} and \ref{query-annotation}).

You can see this change history in the log window (toggled with F8), where the command executed, the time it was issued and, if you use the multi-annotator feature (see \ref{annotatoren}), the annotator are displayed.
You can jump to points in history by clicking the corresponding line in the log window.
But beware! the change history is linear, i.e., if you issue an annotation command while being in a point in history, the commands following this point will be lost.

You can also navigate the history using the \code{undo} and \code{redo} commands – see Section \ref{befehl-undo}.


\subsection{Keyboard shortcuts}\label{shortcuts}

Most of the functions related to navigation and display can be controlled by keybord shortcuts.
The following is a table of the available shortcuts:

\begin{center}
	\begin{tabular*}{\textwidth}{ll}
		\toprule
		Shortcut & Function \\
		\midrule
		Navigation & \\
		\midrule
			Alt + ←/→ & previous/next sentence or section\\
			Alt + Home/End & first/last sentence or section \\
			Alt + p/n & previous/next sentence or section with match\\
			Alt + ↑/↓ & jump into navigation window\\
		\midrule
		Graph & \\
		\midrule
			Ctrl + Shift + −/+ & scale down/up graph\\
			Ctrl + Shift + 0 & zoom to original size (fitting height) \\
			Ctrl + Shift + arrows & move graph\\
			Ctrl + Shift + Home/End & go to left/right edge of graph\\
			Ctrl + Shift + Page up/Page down& go to upper/lower edge of graph\\
			F4 & toggle element references\\
		\midrule
		Window & \\
		\midrule
			F1 & show/hide help window \\
			F2 & show/hide text and sentence annotations\\
			F6 & show/hide filter window\\
			F7 & show/hide search window\\
			F8 & show/hide change log window\\
			F9 & show/hide navigation window\\
		\bottomrule
	\end{tabular*}
\end{center}



\section{Configuration}\label{konfiguration}

There are several aspects of your corpus you may configure. The configuration is done in windows you open with a command from the command line. The available configurations are presented in the following sections.

\subsection{Layers and visualization}\label{ebenenkonfiguration}

The window for configuration of the layers of the currently loaded graph and its visualization is opened with the commmand line command \code{config}.

In the section \textit{general settings}, you can configure the settings for nodes and edges that do not belong to any layer.\footnote{Depending on the browser you use, the color fields are displayed as color picker or as simple text field. In the latter case, you have to provide the color as hexadecimal RGB value: A hash (\code{\#}) followed by three two-digit hexadecimal numbers for red, green and blue, respectively. \code{\#000000}, e.g., stands for black, \code{\#ffffff} for white, \code{\#ff0000} for light red etc.}
\textit{Default color} applies to all nodes and edges that are not tokens and that do not belong to any layer, \textit{token color} applies to tokens, \textit{found color} is used for the highlighting of nodes and edges found in a search, and \textit{filtered color} for elements that are filtered out by the filter function.
The setting for \textit{edge weight} affects the layout of the displayed graph and shows its effect only when edges with different weight are present (details will follow in the next paragraph).
Finally, the setting \textit{edge label compatibility mode} enables a different way of edge label placing.
This leads to a poorer graph layout (more collisions) but avoids graph rendering errors that may occur due to a bug in the graph rendering library (this kind of errors mostly shows up with dependency annotations as these tend to result in densely packed bundles of edges; you’ll see a notice popping up if such an error occurs).

In the section \textit{layers}, you can configure the layers of the graph.
The \textit{name} is an arbitrary label for the layer, that will be shown in the dropdown field for the layer selection.
The \textit{shortcut} is an identifier that is used for representing the layers of elements internally (cf. Section \ref{serialization-format}), for setting the layers of elements (cf. Section \ref{befehl-n} or \ref{befehl-l}) and for matching elements of specific layers in searches; this shortcut may only consist of alphanumeric characters and underscores and must not have the same structure as element references (i.e., \code{t}, \code{n}, \code{e} or \code{s} followed by a number, or  \code{m}; cf. Section \ref{befehl-a}).
\textit{Color} means the color that is used for displaying the elements of the layer; \textit{edge weight} is the weight of the layer’s edges.
The higher this value (integer values), the shorter the rendering algorithm will try to make the edges.
When you create two layers, one with a high edge weight and one with a low edge weight, the graph will be rendered such that the graph of the first layer is as compact as possible; the elements of the second layer will be placed in a way that they distort the first layer only to a low degree.
If you enter \textit{0} as edge weight, the edges will not enforce a hierachy between the nodes of that layer (otherwise, the start node of an edge is always placed higher than the end node).
If a negative value is entered, all nodes of that layer are displayed horizontally on one tier.

The section \textit{layer combinations} contains the settings for elements that belong to multiple layers.
Via the checkboxes under \textit{layers} you determine, to which layers an element has to belong in order to be subject to the definition of the combination in question.
The other settings work like those described for the \textit{layers}, and for those elements that belong to the layer combination, they override the values given for the single layers.
Note that elements can only be assigned to layer combinations that are defined here.\\

Note that changes in the layers window do not affect existing nodes and edges!
That means, e.g., that if you change the shortcut of a layer, the elements formerly belonging to this layer don’t belong to it anymore (but now have a non-meaningful shortcut in their layers list).


\subsection{Permitted annotations / tagset}\label{erlaubteannotationen}

In the window opened by the command \code{tagset}, you can specify which annotations are permitted for the nodes and edges of the graph, i.e., you can define the graph-specific tagset.
Only the keys and values defined here are permitted for the annotation of elements, illicit input is answered with an error message.
Already existing annotations are not affected by changes of the permitted keys and values.
The \code{token} annotation on token nodes – i.e., changing the token text – is always permitted.

If you do not specify any keys and values, all annotations are permitted.
If you specify keys, only these keys are allowed for annotations.
If you leave the value field for a key empty, then all values are permitted for this key.
If you want to restrict the possible values for a key, you may enter these into the value field of the key in question, separated by spaces.

The notation of the values is subject to the same rules as in the query language (cf. Section \ref{node}, p.\,\pageref{zeichenketten}):
Simple values are entered without further markup; if a value contains special characters (see p.\,\pageref{zeichenketten}) it has to be enclosed in double quotes (\code{\quo...\quo}).
Additionally – just like in the query language (p.\,\pageref{zeichenketten}) – you may use regular expressions, which are enclosed in slashes (\code{/.../}).
In this case the regular expressions are anchored, i.e. an annotation value has to match the whole regular expression in order to be permitted.


\subsection{Annotation and search makros}\label{annotationsmakros}

With the command \code{makros} you open a window where you may define makros.
You can define annotation makros, that facilitate the annotation with frequently needed attribute combinations, as well as search makros that you can use in graph searches for frequently used attribute combinations or connection descriptions (cf. Section \ref{def}).

For the annotation makros, you enter the shortcut for your makro (it has to consist of alphanumeric characters including the underscore, and it should not have the form of an element reference or be identical to a layer shortcut, cf. Section \ref{ebenenkonfiguration}) in the fields on the left; in the corresponding field on the right you enter the desired annotations for your makro.
For these annotations you must use the same syntax as in the annotation commands, i.e. a set of attributes in the form \code{key:value}, separated by spaces (see Section \ref{befehl-n} for details).

For the seach makros, you enter the name (again, a string of alphanumeric characters including the underscore) in the left field and a predefined graph-specific search makros as described in Section \ref{def} in the right field.
These makros are then available for search queries in the graph.


\subsection{Metadata}

Additionally to the configuration of layers, visualization, makros and permitted annotations, you may save metadata for a graph as key-value pairs.
The command \code{metadata} opens the window, where you can enter an arbitrary number of keys with a text as corresponding value.


\subsection{Annotators}\label{annotatoren}

For the case of multiple annotators working with the same corpus, GraphAnno offers the possibility of creating annotator-specific annotations.
With this feature, the same elements can be annotated by differend annotators, which enables you, e.g., to assess the inter-annotator agreement.

In order to use the multi-annotator feature, you first have to create annotators; the command \code{annotators} opens the window for this task.
In this window you can create annotators, bearing a unique name (prefer short names without spaces, as these will be used for loggin in) and information about the annotator (free text).
If, later on, you delete annotators, all their annotations will be deleted as well.

If you annotate without having logged in as an annotator, your annotations will be stored as public annotations (as is the case when working without multiple annotators).
For annotating as a specific annotator, you first have to log in using the command \code{annotator} (or the synonymous command \code{user}), followed by the annotator’s unique name.
The current annotator’s name will now be displayed in the corresponding field (next to the input line on the bottom of the user interface), and you will see only your own annotations; the annotations of other annotators or public annotations will be hidden.
Also for searching only your own annotations will be evaluated.
If you want to log out the current annotator and work on the public annotations again, use the \code{annotator} command without argument.


\subsection{File settings}\label{filesettings}

The command \code{file} opens a window, in which you can specify the settings for the file in which the work space will be saved:

\begin{itemize}
	\item	\textit{compact file format}: Should the file be stored in a compact JSON format?
			This has the advantage of reducing the file size, but the file will be less readable for potential inspection or editing in a text editor.
	\item	\textit{save editing history}: Should the the change log (cf. \ref{befehl-undo}) be saved, so that it stays available accross settings?
			%The change log can be saved in the graph file or in another file (with a name of the form \code{<corpus name>.log.json}).
			(Attention, this option can lead to very big files and long saving/loading times.)
	\item	\textit{save window positions}: Should the position of the windows (filter, search etc.) be saved in the graph file (i.e., project-specific)?
			(Otherwise, the positions are only saved in the browser.)
\end{itemize}


\subsection{Program preferences}\label{preferences}

For settings that aren’t related to a corpus but to the program, there is the preferences window, opened by the command \code{pref}.
Currently, these settings comprise only the command line autocomplete feature (cf. \ref{commandline}).
You may activate the autocomplete feature and then choose which kinds of entities (commands, file names, sentence names, annotations, makros etc.) you want to get suggestions for.
Note that the autocomplete feature is useless if you don’t choose things that should be suggested.



\section{Command line commands}\label{commandline-commands}

\subsection{Data and navigation}\label{data-and-navigation}

\subsubsection{Load file: \texttt{load}}

With the command \code{load} you load a graph file into the work space.
By default, the file will be loaded from the \texttt{data} directory located in the GraphAnno main directory; but you can also provide a path (directories are separated by the normal slash \texttt{/} on all operating systems).
If the path does not start with a slash, it will be interpreted relative to the \texttt{data} directory; if it starts with a slash, it will be interpreted as an absolute path (in the partition GraphAnno is installed in if you are working on a Windows systems).
Provide the file name with or without the extension \code{.json}; the path has to be enclosed in double quotes (\code{\quo...\quo}) if it contains spaces.

Before loading, the work space is cleared from all data.
So, changes that were not saved explicitly (using the command \code{save}) are lost.
The name of the loaded file (or the master file in case of multi-file corpora) is shown next to the input line on the bottom of the user interface.

When working with a multi-file corpus, you have two options:
Either you provide the path to the master file, then the whole corpus is loaded into the work space; or you provide the path to a part file, then only this part of the corpus is loaded.
You can add other parts of the corpus using the command \code{add}.


\subsubsection{Add part file of multi-file corpus: \texttt{add}}

The command \code{add} adds to the work space a part file of a multi-file corpus that is already partially loaded.
Provide the path of the part file as described for \code{load}.
You will see an error message if you try to load a file that is not part of the loaded corpus or if the file has been loaded already.


\subsubsection{Append file: \texttt{append}}

The command \code{append} appends the contents of the given file (specify the file as described for \code{load}) to the work space.
If you had loaded a multi-file corpus before, the content of the workspace will be treated as one-file corpus after the \code{append}.


\subsubsection{Save file: \texttt{save}}

The command \code{save} saves the work space to a GraphAnno file (see the command \code{load} for details concerning the file path).
If there is a file name indicated next to the input line, the work space can be saved to this file without specifying the file name.
Attention: no warning is issued when an existing file will be overwritten.

When working with a multi-file corpus, only the loaded parts and the master file will be rewritten (the other parts remain unchanged).
If you specify a new name when saving a partially loaded multi-file corpus, the new corpus will only consist of the loaded parts.


\subsubsection{Clear work space: \texttt{clear}}

The command \code{clear} clears the work space from all data.
Changes that were not saved are lost.
Next to the input line no file will be indicated anymore.


\subsubsection{Go to sentence/section: \texttt{s}}\label{befehl-s}

In order to navigate to a sentence or section (or multiple of them), you may use (alternatively to \hyperref[shortcuts]{keyboard shortcuts} or the \hyperref[window-navigation]{navigation window}) the command \code{s}, followed by the name(s) of the sentence(s) or section(s) you want to change to.


\subsubsection{Save image: \texttt{image}}

With the command \texttt{image}, you can export the graphic that GraphAnno is currently displaying.
As argument you must specify the desired format (\texttt{svg} or \texttt{png}).
The file will then be downloaded.


\subsubsection{Import text: \texttt{import text}}\label{befehl-import}

You can import texts with the command \code{import text}. After issuing the command, a window opens where you can enter the text and set the preferences for its processing.
The work space will be cleared before the text is imported (but not as soon as the window opens).
Changes that hadn’t been saved are lost and no file is indicated next to the input line anymore.

In the import window you can choose between two methods of entering your text:
You can upload a text file or you can paste it in the text area.
For the processing of the text there are two methods available, too.
For unedited text you may use the method \textit{punkt segmenter}.
This method uses an automatic segmenter to split the text into sentences and tokens.
In order to process abbreviation etc. correctly, you need to specify the language of the text.

The second processing method is \textit{regular expressions}; this method is made for preformatted texts.
First, you have to enter a string that will be used for segmenting the sentences.
The preset is \code{{\textbackslash}n} \footnote{\code{{\textbackslash}n} stands for a line break, \code{{\textbackslash}t} for a tab.} for a file in which every sentence starts on a new line.
The second string you have to enter a a regular expression that matches the tokens.
The preset here is \code{({\textbackslash}S+)}.
This stands for a sequence of non-spaces, so all words that are separated by spaces are matched as tokens.
The purpose of the parentheses is to save the matched string in the variable \code{\$1}, so it can be used in the next field.
The next field is for an annotation command (see \ref{befehl-a}) for the tokens, that uses the string matched by the regular expression in the preceding field.
The preset here is \code{token:\$1}.
That means that the string matched as token is used for the annotation of the token text.
Another example would be a text tagged for parts of speech, where the part of speech is appended to every word with an underscore.
In this case you would enter the regular expression \code{({\textbackslash}S+)\_({\textbackslash}S+)} and the annotation command \code{token:\$1 pos:\$2}.
The regular expression in this case finds two strings of non-spaces that are joined by an underscore; the strings are saved to the variables \code{\$1} (the word) and \code{\$2} (the POS tag).
In the annotation command these variables are used to annotate the token text and the \code{pos} attribute.


\subsubsection{Import Toolbox data: \texttt{import toolbox}}

Toolbox files can be imported using the command \code{import toolbox}.
This command opens a window in which you can choose the file to be imported and enter the format description.
The format description has to be in JSON format and consists of a list of a list of markers.
The lists are sorted according to their levels – the highest (\textit{record} level) first – and contain the markers that belong to the respective level (markers are entered without backslash).
The first marker of the first level (\code{ref} in the example below) will be used as record ID.
The marker whose line is to be used as token text is preceded by an asterisk.
Elements that lie below the token level will be joined and integrated into their respective tokens.

A format description for a toolbox file with three levels (record, word, morpheme) could look like this, e.g.:

\begin{lstlisting}[gobble=4]
	[["ref", "eng"], ["*gw"], ["mph", "ge", "ps"]]
\end{lstlisting}

Like with the command \code{load}, the work space will be cleared when importing.
Changes that haven’t been saved will be lost; next to the input line no file will be indicated anymore.


\subsubsection{Export and import configuration: \texttt{export} and \texttt{import}}

The command \code{export} serves also for exporting graph configurations, that can be imported in other graphs using the command \code{import}.
As first argument you enter the type of the configuration to be exported or imported: \code{config} for layers and visualization configuration (see \ref{ebenenkonfiguration}), \code{tagset} for permitted annotations / tagset (see \ref{erlaubteannotationen}).
The second argument is the filename for the configuration file to be saved or to be imported (without file extension).
The exported file will be saved in a subdirectory – named like the configuration type – of the \texttt{exports} directory.
Attention: when importing, the existing configuration will be replaced completely.


\subsubsection{Edit configurations: \texttt{config}, \texttt{tagset}, \texttt{makros}, \texttt{metadata}, \texttt{annotators} and \texttt{file}}

These commands open the windows for the settings that were described in Section \ref{konfiguration}.
\code{config} for layers and visualization, \code{tagset} for permitted annotations / tagset, \code{makros} for annotation makros, \code{metadata} for metadata, \code{annotators} for annotators and \code{file} for file settings.


\subsection{Sections and sentences}

The following commands create, delete or modify sentence and section nodes.
All of these command may take names as parameters.
These names may be given as bare strings or quoted strings (for details see Section \ref{zeichenketten}).

Where you are referencing existing sections/sentences, the names may match more than one section/sentence as the names are not unique by design (it is strongly recommended to keep them unique, though).
In such cases all sections/sentences with the given names are considered. Keep in mind that the referenced sections/sentences must always be one the same level.

You may also reference multiple sections/sentences at once, either by using regular expressions or sequences.
Regular expressions are given in slashes (\code{/.../}) and find all sections/sentences whose names match the expression (for further information regarding regular expressions see \ref{zeichenketten}).

For referencing sequences of sections/sentences, provide the names of the first and the last section/sentence, joined with to dots, e.g., \code{sent-01..sent-13} (this may not work as expected if your names are not unique).
The different methods of referencing section/sentence references may be combined in one command.

\subsubsection{Create new sentence: \texttt{ns}}\label{befehl-ns}

With the command \code{ns} – followed by one or more sentence names – you can create one or more new sentences.
The command creates sentence nodes with the corresponding \code{name} attribute and inserts them after the current sentence (or the last of the current sentences), of which also the possible affiliation to a section is inherited.
Afterwards you are directed to the first one of the new sentences.

\subsubsection{Create section: \texttt{s-new}}

The command \code{s-new} creates a new section.
When you don’t provide any section or sentence names with the command, the new section will comprise the current sentences or sections.
When you provide section or sentence names (the sentences/sections must be contiguous and on the same level), these will be grouped instead of the current ones.
You may alyso provide annotations for the new section (see \ref{befehl-n} for how these have to look like); it is advisable to specify at least the \code{name} attribute.

\subsubsection{Remove section: \texttt{s-rem}}

The command \code{s-rem} is the reverse of \code{s-new}: it removes sections (without touching their descendants).
You cannot remove all sections from their parent section, and you cannot remove sections from the middle of their parent section.
Provide the names of the sections to be removed together with the command.

\subsubsection{Add to section: \texttt{s-add}}

With the command \code{s-add} you can add sections/sentences to an existing section.
Provide the name of the parent section first and then the names of the sections/sentences to be added to the parent section.
The sections/sentences to be added must be contiguous and one level below the parent section.

\subsubsection{Detach section: \texttt{s-det}}

The command \code{s-det} is the reverse of \code{s-add}: it detaches sections/sentences from their parent section.
Restrictions and parameters of the command are the same as for \code{s-rem}.

\subsubsection{Delete section: \texttt{s-del}}

The command \code{s-del} deletes the current sentences or sections including their descendants and all text and annotation contained.
If you provide section or sentence names as arguments, these sections/sentences will be deleted instead of the current ones.


\subsection{Annotation}\label{annotationsbefehle}

GraphAnno’s annotation commands are designed to be entered quickly, so their syntax is rather compact:
they consist of a short command (often one letter only) and are followed by parameters seperated by spaces.

The commands require to be in a sentence, i.e., you have to create a sentence first (using the command \code{ns}, see \ref{befehl-ns}) if the work space is empty.


\subsubsection{New node: \texttt{n}}\label{befehl-n}

The command for creating a new node is \code{n}, followed by the attributes the new node is to bear as key-value pairs in the format \code{key:value}.
Key and value can be given either as simple string (if it doesn’t contain any of the special characters used in the annotation language: \code{␣:\quo\#})\footnote{The symbol \code{\mbox{\,␣\,}} stands for the space.}) or as string in double quotes (\code{\quo...\quo}), that may contain any character (double quotes themselves have to be excaped with a backslash: \code{\quo...\textbackslash\quo...\quo}).

You can also use a shortcut from previously defined annotation makros (see Section \ref{annotationsmakros}).
When you additionally enter attributes with keys present in the makro, these override the annotations defined in the makro.

Additionally, you can specify the layer or layer combination to which the new node is to belong (if you don’t, it will belong to the layer/combination set in the layer dropdown field).
For this purpose you use the shortcuts defined in the layer configuration (cf. Section \ref{ebenenkonfiguration}).
The use of these shortcuts also has the effect of a switch, insofar as it sets the layer/combination for the following operations.
If you want to create a node without layer affiliation, you have to set the current layer to \textit{none} via the command \code{l} (see \ref{befehl-l}) or the layer dropdown.

Per default, the new node will belong to the first of the current sentences.
You may, however, provide in your command a node to whose sentence the new node should belong instead.

\paragraph*{Command \code{n} in modified BNF:}
~
\begin{lstlisting}
command_n            =   "n " n_parameters
n_parameters         =   n_parameters " " n_parameters
                         attributes
                         node_reference
attributes           =   attributes " " attributes
                         attribute
                         annotation_shortcut
                         layer_shortcut
attribute            =   key string
key                  =   string ":"
string               =   character_not_special+
                         """ character* """
alnum                =   letter | digit | "_"
annotation_shortcut  =   alnum+
layer_shortcut       =   alnum+
node_reference       =   anno_node_reference
                         token_node_reference
anno_node_reference  =   "n" number
token_node_reference =   "t" number
\end{lstlisting}


\subsubsection{New edge: \texttt{e}}

The command for creating a new edge is \code{e}, followed by start and end node of the edge to be created and the attributes it is to bear (you may give nodes and attributes in arbitrary order; if you accidently provide more than two nodes, the first two nodes will be considered).
Like with \code{n}, the specification of a layer is possible.

\paragraph*{Command \code{e} in modified BNF:}
~
\begin{lstlisting}
command_e       =   "e " e_parameters
e_parameters    =   e_parameters " " e_parameters
                    node_reference
                    attributes
\end{lstlisting}


\subsubsection{Annotate: \texttt{a}}\label{befehl-a}

The command for annotation elements is \code{a}, followed by the elements to be annotated and the attributes with which they are to be annotated (all given elements will be annotated with all given attributes; also layer shortcuts can be used).
The order of the elements and attributes is free.
You can also annotate sequences of elements of the same type (i.e., \code{n}, \code{e} or \code{t}) by entering the first and the last element joined by two dots.
E.g., when you enter \code{t3..t7}, all tokens from \code{t3} to \code{t7} will be annotated (you may enter the sequence also in the inverse order, i.e., \code{t7..t3}).

At the same time you can use the command \code{a} for deleting attributes.
In order to do so, enter the key to be deleted with colon, but without value.

The command \code{a} also serves for annotating sentences and sections.
The sentence and section nodes are referenced like \code{s0}, \code{s1} etc., where \code{s0} stands for the current sentence(s), \code{s1} for the parent section(s) of the current sentence(s), \code{s2} for the parent(s) of the parent section(s) and so on.

\paragraph*{Command \code{a} in modified BNF:}
~
\begin{lstlisting}
command_a              =   "a " a_parameters
a_parameters           =   a_parameters " " a_parameters
                           element_reference
                           section_node_reference
                           attributes
                           key
element_reference      =   node_reference
                           edge_reference
                           element_sequence
edge_reference         =   "e" number
section_node_reference =   "s" number
element_sequence       =   node_sequence
                           edge_sequence
node_sequence          =   anno_node_sequence
                           token_node_sequence
anno_node_sequence     =   anno_node_reference ".." anno_node_reference
token_node_sequence    =   token_node_reference ".." token_node_reference
edge_sequence          =   edge_reference ".." edge_reference
\end{lstlisting}


\subsubsection{Set layer: \texttt{l}}\label{befehl-l}

The command \code{l} sets the layer or layer combination of the given elements and switches to the specified layer/combination for the following operations.
As arguments, specify the elements to be affected and the layer shortcut as defined in the layer configuration (cf. Section \ref{ebenenkonfiguration}).
If you don’t provide a layer shortcut, the elements are set to belonging to no layer at all, and the current layer is set to \textit{none}.

You may also use the command as a simple layer switch (as an alternative to the select field) by giving only the layer shortcut (or none) without any elements.

\paragraph*{Command \code{l} in modified BNF:}
~
\begin{lstlisting}
command_l     =   "l " l_parameters?
l_parameters  =   l_parameters " " l_parameters
                  element_reference
                  layer_shortcut
\end{lstlisting}


\subsubsection{Delete elements: \texttt{d}}

Elements are deleted with the command \code{d}, followed by the elements to be deleted.
If you delete nodes, the outgoing and ingoing edges are deleted as well.
If you delete a token node from the middle of a sentence, the adjacent tokens are joined automatically.

\paragraph*{Command \code{d} in modified BNF:}
~
\begin{lstlisting}
command_d       =   "d " d_parameters
d_parameters    =   d_parameters " " d_parameters
                    element_reference
\end{lstlisting}


\subsubsection{Group nodes under new parent node: \texttt{g} or \texttt{p}}

The grouping command \code{g} or \code{p} creates a new parent node for the given nodes.
I.e., the command creates a new node and edges that connect the new nodes to the nodes to be grouped.
The parameters of this command are the nodes to be grouped and the attributes the newly created node is to bear.
The newly created node will belong to the sentence of the node given first in your command; apart from that, the order of nodes and attributes is irrelevant.
Like with the command \code{n}, a layer can be specified.

\paragraph*{Command \code{g}/\code{p} in modified BNF:}
~
\begin{lstlisting}
command_g           =   ("g " | "p ") g_parameters
g_parameters        =   g_parameters " " g_parameters
                        node_reference
                        node_sequence
                        attributes
\end{lstlisting}


\subsubsection{Append child node: \texttt{h} or \texttt{c}}

The command \code{h}/\code{c} works analogously to the command \code{g}/\code{p}, but instead of a parent node a new common child node is created.

\paragraph*{Command \code{h}/\code{c} in modified BNF:}
~
\begin{lstlisting}
command_h           =   ("h " | "c ") h_parameters
h_parameters        =   h_parameters " " h_parameters
                        node_reference
                        node_sequence
                        attributes
                        layer_shortcut
\end{lstlisting}


\subsubsection{Insert node into edge: \texttt{ni}}

The command \code{ni} (\textit{node insert}) allows you to insert a new node into an existing edge.
As parameters you specify the edge and the attributes for the new node.
A new node will be created, and the given edge will be replaced by two edges with the same annotations, that connect the start node of the original edge with the new node and the new node with the end node of the original edge.

If you specify more than one edge, a new node will be inserted into each of them

\paragraph*{Command \code{ni} in modified BNF:}
~
\begin{lstlisting}
command_ni          =   "ni " ni_parameters
ni_parameters       =   ni_parameters " " ni_parameters
                        edge_reference
                        attributes
\end{lstlisting}


\subsubsection{Delete node but preserve connections: \texttt{di} und \texttt{do}}

If you want to delete a node but preserve the connections between parent node(s) and child node(s) of the deleted node, you can use the commands \code{di} or \code{do}.
These commands delete the specified node and connect each child node to each mother node (this makes sense particularly in a tree-like structure where there is one parent node and many child nodes).
\code{di} (\textit{delete ingoing}) deletes the ingoing edge(s), \code{do} (\textit{delete outgoing}) deletes the outgoing edge(s).

\paragraph*{Commands \code{di} and \code{do} in modified BNF:}
~
\begin{lstlisting}
command_di_do       =   "di " anno_node_reference+
                        "do " anno_node_reference+
\end{lstlisting}


\subsubsection{Tokenize: \texttt{t}, \texttt{tb}, \texttt{ta}}

For creating tokens there are the commands \code{t}, \code{tb} and \code{ta}.
The arguments for these commands are a list of words, separated by spaces.
These words are inserted as tokens into the current sentence.
If the sentence already contains tokens, the command \code{t} appends the new ones.
\code{tb} (\textit{tokenize before}) and \code{ta} (\textit{tokenize after}) take a token as their first argument and insert the new tokens before or after, respectively.

The words can be given as bare strings, or, if they contain control characters (\code{␣:\quo\#}), as string in double quotes (\code{\quo...\quo}; double quotes inside the string have to be escape with a backslash: \code{\textbackslash\quo}).

\paragraph*{Commands \code{t}, \code{tb}, \code{ta} in modified BNF:}
~
\begin{lstlisting}
befehl_t        =   "t " words
words           =   words " " words
                    word
word            =   non-control-character+
                    """ character* """

command_tb      =   "tb " token_reference " " words
command_ta      =   "ta " token_reference " " words
\end{lstlisting}


\subsubsection{Undo/Redo: \texttt{undo} and \texttt{redo} (or \texttt{z} and \texttt{y})}\label{befehl-undo}

You can undo previously issued annotation commands using the command \code{undo} (or the synonymous command \code{z}).
These annotation commands include those commands that create or delete nodes or edges, as well as creating and deleting of sentences, but not work space-related commands such as \code{append} or \code{clear} and not annotation by query (cf. \ref{query-annotation}).
A command you have undone can be redone with the command \code{redo} (or the synonymous command \code{y}).
Undoing and redoing can be used multiple times; but if you issue an annotation command after having undone other commands, the undone commands cannot be redone (linear change history).

You can look at the change history in the log window that is toggled with the F8 key (cf. Section \ref{window-log}).
In this window you can also directly jump to points in the history with a click.


\subsubsection{Log in annotator: \texttt{annotator} (or \texttt{user})}

If you use GraphAnno’s multi-annotator feature, you log in as a specific annotator with the command \code{annotator} (or the synonymous command \code{user}), followed by the annotator’s unique name (as defined in the corresponding window, see \ref{annotatoren}).
The logged-in annotator will be shown in the field next to the input line and only the annotator’s annotations will be displayed and searched.
If you want to log out the current annotator and work on the public annotations again, use the \code{annotator} command without argument.



\section{Query language}\label{querylanguage}

\subsection{Search}

Searching graphs in GraphAnno works by formulating a query that describes a graph fragment and is composed of a set of clauses.
The search then finds all subgraphs of the corpus graph that match this description.
The clauses that can be used in the description are the \code{node}, \code{nodes}, \code{edge}, \code{link}, \code{text}, \code{meta}, \code{cond} and \code{def} clauses.
Of these, a query must at least contain one \code{node} clause or \code{text} clause, or an unconnected \code{edge} clause.
The various types of clauses will be explained in the following sections.

In a query the clauses are each given on one line in an arbitrary order; indentations and blank lines have no impact on the semantics.
Comments may be added as whole lines or after a line; they are preceded by a hash symbol.

Of the following sections, the first one explains how a to-be-matched element is described, which is needed for most of the clause types, the subsequent sections present the available clause types in detail.

\subsubsection{Element description}\label{elementbeschreibung}

An \textit{element description} is the part of a query clause that defines which properties an element (node or edge) must have in order to be matched by a query.
Such an element description defines which conditions the attributes and layers of an element should match and, additionally, it may specify conditions on ingoing and outgoing edges (for nodes) as well as conditions on start and end nodes (for edges).\\

The description of the attributes is composed of key-value pairs of the form \code{key:value}, that are joined by the logical operators \code{!} for \textit{not}, \code{\&} for \textit{and} and \code{|} for \textit{or} (precedence: \code{!} > \code{\&} > \code{|}) as well as (round) parentheses.
As a shortcut for disjunctions of key-value pairs with the same key, you may use a key-value pair description of the form \code{key:value1|value2|...|valueN}.

The key of a key-value pair can be given as a simple string if it does not contain any of the control characters of the query language (\code{␣():!\&\quo/?+*\{\}@\#\textasciicircum}), else it has to be given in double quotes (\code{{\quo}xyz\quo}) and can then contain any character (double quotes have to be escaped with a backslash: \code{\textbackslash\quo}).

\phantomsection\label{zeichenketten}The values of the key-value pairs are strings, that can be given in three different formats.
The first format is a simple, unmarked string that may contain all characters except the control characters of the query language (\code{␣():!\&\quo/?+*\{\}@\#\textasciicircum}).
These strings will be matched case-insensitively.
The second format is a string in double quotes (\code{{\quo}xyz\quo}).
These strings may contain any character (double quotes have to be escaped with a backslash: \code{\textbackslash\quo}) and will be matched exactly.
The third format is a regular expression.
A regular expression has to be written in slashes (\code{/x.z/}) and has to conform to Ruby’s regular expression syntax (cf. \url{http://www.ruby-doc.org/core/Regexp.html}).
The regular expressions are not anchored; i.e., for anchoring a regular expression to the start or end of a string you have to use \code{\textasciicircum} or \code{\$}, respectively.
You can find an arbitrary string using an empty regular expression (i.e. \code{//}).

If you omit a value string, those elements are matched that bear no annotation at all for the given key. So, e.g., \code{tns:} matches all elements without a tns annotation, \code{!tns:} matches all elements with a tns annotation, \code{tns:|prs} matches all elements with the tns annotation prs or no tns annotation.\\

For matching the layer of an element, you use the shortcut defined for that layer (cf. Section \ref{ebenenkonfiguration}).
Layer shortcuts can be combined using logical operators just like key-value pairs.
So, if you want to find elements with a specific layer combination you may of course use the respective layer shortcuts joined by \code{\&}, but also the shortcut for that combination.

Token nodes are matched by using the keyword \code{token}.\\

\phantomsection\label{quantifiers}For nodes, the element description may, in addition to key-value pairs and layer shortcuts, contain criteria for ingoing and outgoing edges.
These criteria are composed of the keyword \code{in} or \code{out}, an optional element description in parentheses and an optional quantifier.
The operators \code{in} or \code{out} find all ingoing or outgoing edges, respectively, that match the given element description.
The quantifier specifies how many edges matching the given description have to be present; its syntax is familiar from regular expressions:
\code{\{m,n\}} means at least m edges, at most n edges; if you omit the first number, it has the meaning \textit{zero}, omitting the second number means \textit{infinite}.
\code{\{n\}} means exactly n edges.
Additionally there are the shortcuts \code{?} for \code{\{0,1\}}, \code{*} for \code{\{0,\}} and \code{+} for \code{\{1,\}}.
What differs from quantifiers in usual regular expressions (and from quantifiers in other contexts of the GraphAnno query language), is that a missing quantifier will be interpreted as \code{\{1,\}}.

The operator \code{link} works in a similar fashion to \code{in} and \code{out}, but it does not find ingoing and outgoing edges but (potentially) more complex connections to other nodes.
In Section \ref{link} you may read how these connections may be specified.
The rules for quantifiers used together with the \code{link} operator are the same as for \code{in} and \code{out}.

The operators \code{in}, \code{out} and \code{link} are meaningless if used on the description of an edge; they always match with a count of 1 when used on edges.\\

For edges, the element description may contain, additionally to the key-value pairs, properties of the start or end node, specified with the keyword \code{start} or \code{end}, respectively, followed by the node description in parentheses.

The operators \code{start} and \code{end} are meaningless in node descriptions; they always match when used on nodes.

\paragraph*{The element description in modified BNF:}
~
\begin{lstlisting}
element_description = element_description" & " element_description
                      element_description" | " element_description
                      "!" element_description
                      "(" element_description ")"
                      attribute
                      layer_shortcut
                      edge_criterion
                      node_criterion
                      "token"
attribute           = string ":" attribute_value ("|" attribute_value)*
attribute_value     = char_except_control_char+
                      """ character* """
                      "/" regular_expression "/"
                      ""
string              = char_except_control_char+
                      """ character* """
edge_criterion      = "in" ("(" element_description")")? quantifier?
                      "out" ("(" element_description")")? quantifier?
                      "link" ("(" connection ")") quantifier?
quantifier          = "?" | "*" | "+" | "{" number? ("," number?) "}"
node_criterion      = "start" ("(" element_description ")")
                      "end" ("(" element_description ")")
\end{lstlisting}


\subsubsection{\texttt{node}}\label{node}

The \code{node} clause describes a node that should occur once in the graph fragment.
The clause is composed of the keyword \code{node}, an optional ID and an element description.

The ID consists of a \code{@} followed by a string that consists of alphanumeric characters, including the underscore, with the additional restriction that the first character must not be a digit.
Using this ID, the node can be referenced in other parts of the query.

\paragraph*{The \code{node} clause in modified BNF:}
~
\begin{lstlisting}
node_clause     =   "node" id? " " element_description
id              =   "@" (letter | "_") alphanumeric_char*
\end{lstlisting}

\paragraph*{Examples:}
\begin{itemize}
	\item Search for all nodes that bear the category S or VP and that are no tokens:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node cat:S|VP & !token
	\end{lstlisting}
	\item Search for all nodes of category VP or tokens bearing the pos value verb:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node cat:VP | token & pos:verb
	\end{lstlisting}
	\item Search for all nodes of category S that have at least two outgoing AUX edges:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node cat:S & out(cat:AUX){2,}
	\end{lstlisting}
	\item Search for all nodes of category S that directly dominate at least one node bearing the pos value pro:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node cat:S & out(end(pos:pro))
	\end{lstlisting}
\end{itemize}


\subsubsection{\texttt{nodes}}

The \code{nodes} clause describes a set of nodes that should be present in the graph fragment.
The set may end up being empty if it is only the target of a \code{link} clause or \code{edge} clause.
The \code{nodes} clause has the same syntax as the \code{node} clause (except for the keyword, of course).

\paragraph*{The \code{nodes} clause in modified BNF:}
~
\begin{lstlisting}
nodes_clause    =   "nodes" id? " " element_description
\end{lstlisting}


\subsubsection{\texttt{edge}}\label{edge}

The \code{edge} clause may be used in two different ways.
First, you can use it for searching for single edges.
Then the clause consists of the keyword \code{edge}, an optional ID (under which the edge can be references in the exporting function) and an attribute description for edges as explained above in \ref{node}.
Second, you can use the \code{edge} clause for stating the there should be an edge with the specified properties between two nodes or sets of nodes (specified via \code{node} or \code{nodes}, respectively) of the graph fragment.
When used in this way, you have to provide the IDs of start and end of the edge after the (optional) ID of the edge itself.

Conditioned by the optional ID and the various usages, the keyword \code{edge} my be followed by zero up to three IDs.
The interpretation of these IDs follows from ther number and their order.
One ID: ID of the edge itself; two IDs: start and end of the edge; three IDs: ID of the edge, IDs of start and end.

\paragraph*{The \code{edge} clause in modified BNF:}
~
\begin{lstlisting}
edge_clause     =   "edge" id? (id id)? " " element_description
\end{lstlisting}

\paragraph*{Examples:}
\begin{itemize}
	\item Search for all edges that indicate the syntactic function subject:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		edge synfunc:subj
	\end{lstlisting}
	\item Search for all nodes of cateory S, each with the set of nodes of category NP that are linked via an edge of category S, A or P:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node  @s    cat:S
		nodes @np   cat:NP
		edge  @s@np cat:S|A|P
	\end{lstlisting}
\end{itemize}


\subsubsection{\texttt{link}}\label{link}

A \code{link} clause specifies how two nodes or node sets of the graph fragment should be connected.
The connection can be specified flexibly as a chain of nodes and edges using quantifiers and disjunctions similar to a regular expression.
The \code{link} clause consists of the keyword \code{link}, the specification of the start and end nodes (via IDs as described for the \code{edge} clause above) and the description of the connection.

The description of the connection consists of a sequence of \code{edge} and \code{node} terms.
These terms are composed of the keyword \code{edge} or \code{node} and an optional description of the element in parentheses.
This description is an attribute description as explained for the \code{node} clause above.
The element description may be followed by an ID, under which the found elements can be references in the exporting function (but not in the search query!).

For alternatives you may use the \textit{or} operator \code{|}; its precedence is lower than that of the sequence.
You may use parentheses for adjusting the precedence.
You may also use quantifiers (as described under \ref{nodes} on page \pageref{quantifiers}) after elements or elements grouped in parentheses.
These quantifiers are interpreted neither as greedy nor as non-greedy – all matching connections will be found and counted as separate matches.

Corresponding to the nature of a graph, a connection always consists of an alternating sequence of nodes and edges (starting and ending with an edge).
When specifying a connection, however, it is not obligatory to provide an alternating sequence; only the first edge must not be omitted.
If you provide two elements of the same type (i.e. edges or nodes) in succession, the search engine will accept any element of the other type in between.
E.g., the connection description \code{edge(a:b) edge(c:d)} will match an edge bearing the attribute \code{a:b}, en unspecified node an then another edge, bearing the attribute \code{c:d}.

When you use \code{link} in a node attribute (e.g. in a \code{node} clause), do not provide start and end node.
The start node then is the node that is searched for; the end node is the last node that is described in the connection description or, if the connection description ends with an edge, an unspecified node.

\paragraph*{The \code{link} clause in modified BNF:}
~
\begin{lstlisting}
link_clause     =   "link" id id " " connection
connection      =   connection " " connection
                    connection "|" connection
                    "(" connection ")"
                    connection quantifier
                    "edge" ("(" element_description ")")? id?
                    "node" ("(" element_description ")")? id?
\end{lstlisting}

\paragraph*{Examples:}
\begin{itemize}
	\item Search for all graph fragments that are composed of a node of category P and a node of cateogry S, where the former dominates the latter via an edge of category EX:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @p cat:P
		node @s cat:S
		link @p@s edge(cat:EX)
	\end{lstlisting}
	\item Search for a node of catogory S, all nodes of category NP that are dominated by the S node and all tokens that are dominated by these NP nodes:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @s cat:S
		nodes @np cat:NP
		nodes @tok token
		link @s@np edge+
		link @np@tok edge+
	\end{lstlisting}
	\item Search for a node of catogory S and all tokens that are dominated by the S node via an NP node (this yields the same graph fragments as the last example, but without assigning an ID to the NP nodes):
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @s cat:S
		nodes @tok token
		link @s@tok edge+ node(cat:NP) edge+
	\end{lstlisting}
	\item Search for a node of catogory NP and the next dominating node of category S (i.e., without intervening S nodes):
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @np cat:NP
		node @s cat:S
		link @s@np edge node(!cat:S)*
	\end{lstlisting}
\end{itemize}


\subsubsection{\texttt{text}}

With the \code{text} clause you can find a series of token nodes by specifying their text.
Additionally you may specify other attributes the token nodes should bear.
The \code{text} clause is composed of the keyword \code{text}, an optional ID and the description of a text fragment.

The description of the text fragment consists of a sequence of word descriptions that describe the token text and an optional attribute description in parentheses for each token.
For specifying the token text there are three posiibilities as is described in \ref{node} for the values of key-value pairs: bare strings, quoted strings and regular expressions; the attribute descriptions follow the same rules as in \ref{node}, too.

For the description of the text fragment you may use the operator \code{|} for \textit{or} (precedence lower than sequence) as well as parentheses and quantifiers (these are non-greedy in the text search).
Additionally you can append an ID to a subgroup of your text fragment that enables referencing these nodes in other clauses.
Quantifiers and IDs have a higher precence than sequence and disjunction; the order of quantifier and ID after the same subgroup does not matter.
The optional ID after the keyword \code{text} captures all nodes that are found in by the clause.
The fragment may be anchored to the start or end of a sentence by \code{\textasciicircum s}; it is not possible to search for text accross sentences.

\paragraph*{The \code{text} clause in modified BNF:}
~
\begin{lstlisting}
text_clause     =   "text" id? " " "^s"? text_fragment "^s"?
text_fragment   =   text_fragment " " text_fragment
                    text_fragment "|" text_fragment
                    "(" text_fragment ")"
                    text_fragment quantor
                    text_fragment id
                    word
word            =   attribute_value ("(" element_description")")?
\end{lstlisting}

\paragraph*{Examples:}
\begin{itemize}
	\item Search for all sentences that contain the verb “permit” in third position:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		text ^s //{2,2} permit(pos:v)
	\end{lstlisting}
	\item Search for two occurrences of “he” that are separated by an arbitrary number of words, where the first “he” and all following words before the second “he” are dominated by an S node:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @s cat:S
		text (he //*)@t he
		link @s@t edge+
	\end{lstlisting}
\end{itemize}



\subsubsection{\texttt{meta}}

The \code{meta} clause restricts the set of sentences to be searched.
In this clause you can declare properties the sentence or its containing sections should have.
Where there are conflicting annotations in the section hierarchy, the respective attribute of the lower section node is considered.

The clause is coposed of the keyword \code{meta} and an attribute description (like an element description, but only referring to annotations, not to ingoing or outgoing edges).

\paragraph*{The \code{meta} clause in modified BNF:}
~
\begin{lstlisting}
meta_clause     =   "meta " attributes
attributes      =   attributes" & " attributes
                    attributes" | " attributes
                    "!" attributes
                    "(" attributes ")"
                    attribute
\end{lstlisting}


\subsubsection{\texttt{cond}}\label{cond}

With the \code{cond} clause you can specify conditions the graph fragment has to fulfil.
It works as a filter on the set of graph fragments found based on the rest of the query.
The clause is composed of the keyword \code{cond} and the condition in Ruby code.
The nodes and node sets are referenced with the IDs used in the other clauses of the query.
When using IDs, note that the nodes and edges found by \code{node} and \code{edge} are single elements, whereas those found by \code{nodes}, \code{text} and \code{link} are arrays of elements.

In the condition, you may access the attributes of elements using square brackets like this: \code{['key']}; for the attributes \code{token} and \code{cat} you can use as a shortcut the accessor methods \code{.token} and \code{.cat}.
The layer(s) of an element are accessed via the method \code{.layers}; this method returns an array of the shortcuts of the layers the element belongs to.
Via the method \code{.sentence} you can access the sentence node the element belongs to.
When using attribute values, bear in mind that these are always strings; you may cast them to numbers with \code{.to\_i} or \code{.to\_f} for integers or floating point numbers, respectively.


\paragraph*{Examples:}
\begin{itemize}
	\item Search for two S nodes that are linked via an ad edge and bear the same value for tns:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @s1 cat:S
		node @s2 cat:S
		link @s1@s2 cat:ad
		cond @s1['tns'] == @s2['tns']
	\end{lstlisting}
	\item Search for all S nodes that dominate at least three tokens:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		node @s cat:S
		nodes @tok token
		link @s@tok edge+
		cond @tok.length >= 3
	\end{lstlisting}
\end{itemize}


\subsubsection{\texttt{def}}\label{def}

With \code{def} you can define makros for use in your query.
After the keyword \code{def} you specify a name for the makro and an attribute description or connection description that will be filled in for your makro.
The attribute or connection description is formulated as described in \ref{elementbeschreibung} or \ref{link}, respectively.

Bear in mind that a makro will be interpreted as it was in parentheses, i.e. it will be evaluated first.
E.g., if you define a makro \code{cat:S | cat:VP} and combine it with the condition \code{tns:prs} using the operator \code{\&}, this will not be evaluated as \code{cat:S | cat:VP \& tns:prs} with the \code{\&} preceding the \code{|} but as \code{(cat:S | cat:VP) \& tns:prs}.

\paragraph*{The makro definition \code{def} in modified BNF:}
~
\begin{lstlisting}
makro_definition =   "def " name " " makro
makro            =   element_description
                     connection
name             =   alnum+
\end{lstlisting}


\paragraph*{Examples:}
\begin{itemize}
	\item Search for two nodes with \code{cat:S} or \code{cat:VP} that are linked via one edge and where the second one is in present tense:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		def svp cat:S | cat:VP
		node @s1 svp
		node @s2 svp & tns:prs
		edge @s1@s2
	\end{lstlisting}
%\begin{itemize}
%	\item Suche zwei Knoten mit \code{lemma:cum} und \code{pos:G-}, die über eine Kante verbunden sind, und von denen einer ein Token ist:\\
%	{\tt
%	def cum lemma:cum \& pos:G-\\[-.4ex]
%	node @s1 cum\\[-.4ex]
%	node @s2 cum \& token\\[-.4ex]
%	edge @s1@s2\\[-.4ex]
%	}
\end{itemize}



\subsection{Annotation}\label{query-annotation}

After performing a search you can automatically annotate elements of the found graph fragments using the IDs used in your search query.
For this purpose you can use the annotation commands described in \ref{annotationsbefehle} (except for \code{t}).

Because of the other using context you have take account of some changes:
\begin{itemize}
	\item Instead of the node and edge references in the form of \code{n7}, \code{t8} or \code{e13} you use the IDs defined in your search query (in the form of \code{@s1} or the like).
	\item There is no annotation layer set. You should use a layer switch in your first annotation command (if needed).
	\item When using the command \code{n}, it is obligatory to specify a node that determines the sentence the new node will belong to.
	\item As the IDs can stand for single elements as well as for sets of elements, you have to note some particularities: For the command \code{e} you have to give exactly two IDs; if these are single element IDs, a single edge will be created; if they are one single element IDs and one set ID or two set IDs, an edge will be created for each of the node combinations from the two IDs. For the tokenizing commands \code{tb} and \code{ta} the first or last token of the set, respectively, will be used if you give a set IDs. In all other commands you can give an arbitrary number of set IDs or single element IDs. All given elements then will be treated as \textit{one} set of elements.
	\item When specifying attributes, you can use the elements found in your search. For this purpose, write the value string in double quotes and interpolate a part of the string in Ruby code (in which you can use your IDs) wrapped in braces with a prepended hash sign (as you also do in plain Ruby). As an example, a search/annotation combination that annotates all nodes of category S with their dominated text (terminated with a full stop) could look like this:
	\begin{lstlisting}[gobble=8]
		node @s cat:S
		a @s text:"#{@s.text}."
	\end{lstlisting}
\end{itemize}


\subsection{Data export}

The GraphAnno query language also gives you the possiblity to export search results as CSV files.
With the clauses \code{col} and \code{sort}, described in the following, you can specify which information about the graph fragments found in your search should be exported and in which form.
The data of each found graph fragment will be written in one line of the CSV file; with \code{sort} you can sort the matches and with \code{col} you specify which columns with which values are to be created.
There will always be a first column with a consecutive numbering of the matches.


\subsubsection{\texttt{col}}

Each \code{col} clause stands for a column in the CSV data to be exported.
Its first parameter is the column title (which must not contain spaces); it is followed by Ruby code that yields the value to emit.
Nodes and edges are referenced using the IDs defined in your search query.
Again, bear in mind that the nodes and edges found by \code{node} and \code{edge} are single elements, whereas those found by \code{nodes}, \code{text} and \code{link} are arrays of elements.

You can access the attributes and layers as described in \ref{cond} for \code{cond}.
There are also other useful methods for exporting data:
E.g., \code{.tokens} returns a list of the dominated tokens (you may also give a more specific link description string as argument of the method); \code{.text} works in the same way but returns the token text as a string.
\code{.sentence\_tokens} returns a list of all token nodes of the sentence the element belongs to, \code{.sentence\_text}, again, their text.

When working with the multi-annotator feature (cf. \ref{annotatoren}), the direct access to the attributes (using square brackets) will return the annotations of the current annotator.
If you want to access the annotations of other annotators, use the method \mbox{\code{.private\_attr}}, which takes as argument the name of the annotator,\\e.g., \code{@s.private\_attr('thomas')['cat']}).
For the public annotations, use the method \code{.public\_attr} (e.g., \code{@s.public\_attr['cat']}).


\subsubsection{\texttt{sort}}

The \code{sort} clause can be used for sorting the matches.
When you use multiple \code{sort} clauses, clauses specified later will only be evaluated when the clauses specified further up do not yield an order.

The \code{sort} clause uses Ruby code which yields the value that will be compared for sorting the matches.
Like with \code{col}, the nodes and edges are references via the IDs defined in your search query.
Again, bear in mind that attribute values are always strings and have to be casted to numbers (\code{.to\_i} or \code{.to\_f}) when you expect them to be compared as numbers.

\paragraph*{Examples:}
\begin{itemize}
	\item Sort the matches by sentence name or, if they belong to the same sentence, token ID (the method \code{.tokenid} returns the position of the token in its sentence, starting with 0). Given by the search query: the ID \code{@t1} referring to a token:
	\begin{lstlisting}[gobble=8,aboveskip=.6em,belowskip=.2em]
		sort @t1.sentence.name
		sort @t1.tokenid
	\end{lstlisting}
\end{itemize}



\end{document}